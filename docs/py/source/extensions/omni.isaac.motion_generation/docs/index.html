<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Motion Generation Extension [omni.isaac.motion_generation] &mdash; isaac_sim 2022.2.1-rc.14 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/omni-style.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/api-styles.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/mermaid-init.js"></script>
        <script src="../../../../_static/design-tabs.js"></script>
        <script src="https://unpkg.com/mermaid@9.1.5/dist/mermaid.min.js"></script>
        <script>initMermaid();</script>
        <script src="../../../../_static/version.js"></script>
        <script src="../../../../_static/social-media.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Lula [omni.isaac.lula]" href="../../omni.isaac.lula/docs/index.html" />
    <link rel="prev" title="Debug Drawing [omni.isaac.debug_draw]" href="../../omni.isaac.debug_draw/docs/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html">
            <img src="../../../../_static/main_ov_logo_square.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Main Extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.core/docs/index.html">Core [omni.isaac.core]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.core_nodes/docs/index.html">Core Omnigraph Nodes [omni.isaac.core_nodes]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.dynamic_control/docs/index.html">Dynamic Control [omni.isaac.dynamic_control]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.kit/docs/index.html">Simulation Application [omni.isaac.kit]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.utils/docs/index.html">Utilities [omni.isaac.utils]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.ui/docs/index.html">UI Utilities [omni.isaac.ui]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.kit.loop-isaac/docs/index.html">Time Stepping Control [omni.kit.loop-isaac]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.cloner/docs/index.html">Isaac Cloner [omni.isaac.cloner]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.gym/docs/index.html">RL [omni.isaac.gym]</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Sensor Extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.sensor/docs/index.html">Isaac Sensor Extension [omni.isaac.sensor]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.range_sensor/docs/index.html">Range Based Sensor Simulation [omni.isaac.range_sensor]</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Asset Conversion Extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.urdf/docs/index.html">URDF Import Extension [omni.isaac.urdf]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.mjcf/docs/index.html">MJCF Import Extension [omni.isaac.mjcf]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.shapenet/docs/index.html">ShapeNet [omni.isaac.shapenet]</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Robot Extensions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.dofbot/docs/index.html">Dofbot Robot [omni.isaac.dofbot]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.franka/docs/index.html">Franka Robot [omni.isaac.franka]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.wheeled_robots/docs/index.html">Wheeled Robots [omni.isaac.wheeled_robots]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.universal_robots/docs/index.html">Universal Robots [omni.isaac.universal_robots]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.quadruped/docs/index.html">Quadruped Robots [omni.isaac.quadruped]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.manipulators/docs/index.html">Manipulators [omni.isaac.manipulators]</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Extensions</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.ros_bridge/docs/index.html">ROS Bridge [omni.isaac.ros_bridge]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.ros2_bridge/docs/index.html">ROS2 Bridge [omni.isaac.ros2_bridge]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.debug_draw/docs/index.html">Debug Drawing [omni.isaac.debug_draw]</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Motion Generation Extension [omni.isaac.motion_generation]</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#world-interface">World Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#motion-policy-interface">Motion Policy Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#articulationmotionpolicy">ArticulationMotionPolicy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kinematicssolver">KinematicsSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#articulationkinematicssolver">ArticulationKinematicsSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#path-planning-interface">Path Planning Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trajectory">Trajectory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lula-trajectory-generators">Lula Trajectory Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#articulationtrajectory">ArticulationTrajectory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-omni.isaac.motion_generation.motion_policy_controller">Motion Policy Base Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-omni.isaac.motion_generation.wheel_base_pose_controller">Wheel Base Pose Controller</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.lula/docs/index.html">Lula [omni.isaac.lula]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.surface_gripper/docs/index.html">Surface_gripper [omni.isaac.surface_gripper]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.synthetic_utils/docs/index.html">Tools for Generating Synthetic Data [omni.isaac.synthetic_utils]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.occupancy_map/docs/index.html">Occupancy Extension [omni.isaac.occupancy_map]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.replicator.isaac/docs/index.html">Replicator Isaac Extension [omni.replicator.isaac]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.conveyor/docs/index.html">Conveyor [omni.isaac.conveyor]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../omni.isaac.examples_nodes/docs/index.html">Isaac Sim Examples Nodes [omni.isaac.examples_nodes]</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">isaac_sim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Motion Generation Extension [omni.isaac.motion_generation]</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="motion-generation-extension-omni-isaac-motion-generation">
<h1>Motion Generation Extension [omni.isaac.motion_generation]<a class="headerlink" href="#motion-generation-extension-omni-isaac-motion-generation" title="Permalink to this headline"></a></h1>
<section id="world-interface">
<h2>World Interface<a class="headerlink" href="#world-interface" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">WorldInterface</span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface" title="Permalink to this definition"></a></dt>
<dd><p>Interface for translating USD world to a generic world-aware algorithm such as a MotionPolicy</p>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.update_world">
<span class="sig-name descname"><span class="pre">update_world</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updated_obstacles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.update_world" title="Permalink to this definition"></a></dt>
<dd><p>Applies all necessary updates to the internal world representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>updated_obstacles</strong> (<em>list</em><em>, </em><em>optional</em>) – If provided, only the given obstacles will have their poses updated.
For motion policies that use obstacle poses relative to the robot base (e.g. Lula based policies),
this list will be ignored if the robot base has moved because all object poses will have changed
relative to the robot. Defaults to None.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.add_obstacle">
<span class="sig-name descname"><span class="pre">add_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static:</span> <span class="pre">typing.Optional[bool]</span> <span class="pre">=</span> <span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.add_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Add an obstacle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obstacle</strong> (<em>omni.isaac.core.objects</em>) – An obstacle from the package omni.isaac.core.obstacles
The type of the obstacle will be checked, and the appropriate add function will be called</p></li>
<li><p><strong>static</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – When True, the obstacle will be assumed to remain stationary relative to the USD global frame over time</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns True if the obstacle type is valid and the appropriate add function has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>success (bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.add_cuboid">
<span class="sig-name descname"><span class="pre">add_cuboid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cuboid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicCuboid" title="omni.isaac.core.objects.cuboid.DynamicCuboid"><span class="pre">omni.isaac.core.objects.cuboid.DynamicCuboid</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.FixedCuboid" title="omni.isaac.core.objects.cuboid.FixedCuboid"><span class="pre">omni.isaac.core.objects.cuboid.FixedCuboid</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCuboid" title="omni.isaac.core.objects.cuboid.VisualCuboid"><span class="pre">omni.isaac.core.objects.cuboid.VisualCuboid</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.add_cuboid" title="Permalink to this definition"></a></dt>
<dd><p>Add a block obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cuboid</strong> (<em>core.objects.cuboid</em>) – Wrapper object for handling rectangular prism Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that cuboid will never change pose, and may be ignored in internal
world updates. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if underlying WorldInterface has implemented add_cuboid()</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.add_sphere">
<span class="sig-name descname"><span class="pre">add_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicSphere" title="omni.isaac.core.objects.sphere.DynamicSphere"><span class="pre">omni.isaac.core.objects.sphere.DynamicSphere</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualSphere" title="omni.isaac.core.objects.sphere.VisualSphere"><span class="pre">omni.isaac.core.objects.sphere.VisualSphere</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.add_sphere" title="Permalink to this definition"></a></dt>
<dd><p>Add a sphere obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sphere</strong> (<em>core.objects.sphere</em>) – Wrapper object for handling sphere Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that sphere will never change pose, and may be ignored in internal
world updates. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if underlying WorldInterface has implemented add_sphere()</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.add_capsule">
<span class="sig-name descname"><span class="pre">add_capsule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">capsule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicCapsule" title="omni.isaac.core.objects.capsule.DynamicCapsule"><span class="pre">omni.isaac.core.objects.capsule.DynamicCapsule</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCapsule" title="omni.isaac.core.objects.capsule.VisualCapsule"><span class="pre">omni.isaac.core.objects.capsule.VisualCapsule</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.add_capsule" title="Permalink to this definition"></a></dt>
<dd><p>Add a capsule obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>capsule</strong> (<em>core.objects.capsule</em>) – Wrapper object for handling capsule Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that capsule will never change pose, and may be ignored in internal
world updates. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if underlying WorldInterface has implemented add_capsule()</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.add_cylinder">
<span class="sig-name descname"><span class="pre">add_cylinder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cylinder</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicCylinder" title="omni.isaac.core.objects.cylinder.DynamicCylinder"><span class="pre">omni.isaac.core.objects.cylinder.DynamicCylinder</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCylinder" title="omni.isaac.core.objects.cylinder.VisualCylinder"><span class="pre">omni.isaac.core.objects.cylinder.VisualCylinder</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.add_cylinder" title="Permalink to this definition"></a></dt>
<dd><p>Add a cylinder obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cylinder</strong> (<em>core.objects.cylinder</em>) – Wrapper object for handling rectangular prism Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that cuboid will never change pose, and may be ignored in internal
world updates. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if underlying WorldInterface has implemented add_cylinder()</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.add_cone">
<span class="sig-name descname"><span class="pre">add_cone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cone</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicCone" title="omni.isaac.core.objects.cone.DynamicCone"><span class="pre">omni.isaac.core.objects.cone.DynamicCone</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCone" title="omni.isaac.core.objects.cone.VisualCone"><span class="pre">omni.isaac.core.objects.cone.VisualCone</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.add_cone" title="Permalink to this definition"></a></dt>
<dd><p>Add a cone obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cone</strong> (<em>core.objects.cone</em>) – Wrapper object for handling cone Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that cone will never change pose, and may be ignored in internal
world updates. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if underlying WorldInterface has implemented add_cone()</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.add_ground_plane">
<span class="sig-name descname"><span class="pre">add_ground_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_plane</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.GroundPlane" title="omni.isaac.core.objects.ground_plane.GroundPlane"><span class="pre">omni.isaac.core.objects.ground_plane.GroundPlane</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.add_ground_plane" title="Permalink to this definition"></a></dt>
<dd><p>Add a ground_plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ground_plane</strong> (<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.GroundPlane" title="omni.isaac.core.objects.ground_plane.GroundPlane"><em>core.objects.ground_plane.GroundPlane</em></a>) – Wrapper object for handling ground_plane Usd Prims.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if underlying WorldInterface has implemented add_ground_plane()</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.disable_obstacle">
<span class="sig-name descname"><span class="pre">disable_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.disable_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Disable collision avoidance for obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.object</em>) – obstacle to be disabled.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully disabled.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.enable_obstacle">
<span class="sig-name descname"><span class="pre">enable_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.enable_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Enable collision avoidance for obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.object</em>) – obstacle to be enabled.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully enabled.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.remove_obstacle">
<span class="sig-name descname"><span class="pre">remove_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.remove_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Remove obstacle from collision avoidance. Obstacle cannot be re-enabled via enable_obstacle() after
removal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.object</em>) – obstacle to be removed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully removed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.WorldInterface.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.WorldInterface.reset" title="Permalink to this definition"></a></dt>
<dd><p>Reset all state inside the WorldInterface to its initial values</p>
</dd></dl>

</dd></dl>

</section>
<section id="motion-policy-interface">
<h2>Motion Policy Interface<a class="headerlink" href="#motion-policy-interface" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.MotionPolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MotionPolicy</span></span><a class="headerlink" href="#omni.isaac.motion_generation.MotionPolicy" title="Permalink to this definition"></a></dt>
<dd><p>Interface for implementing a MotionPolicy: a collision-aware algorithm for dynamically moving a robot to a target.  The MotionPolicy interface inherits
from the WorldInterface class.  A MotionPolicy can be passed to an ArticulationMotionPolicy to streamline moving the simulated robot.</p>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.MotionPolicy.set_robot_base_pose">
<span class="sig-name descname"><span class="pre">set_robot_base_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_translation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robot_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.MotionPolicy.set_robot_base_pose" title="Permalink to this definition"></a></dt>
<dd><p>Update position of the robot base.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_translation</strong> (<em>np.array</em>) – (3 x 1) translation vector describing the translation of the robot base relative to the USD stage origin.
The translation vector should be specified in the units of the USD stage</p></li>
<li><p><strong>robot_orientation</strong> (<em>np.array</em>) – (4 x 1) quaternion describing the orientation of the robot base relative to the USD stage global frame</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.MotionPolicy.compute_joint_targets">
<span class="sig-name descname"><span class="pre">compute_joint_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_joint_velocities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watched_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watched_joint_velocities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_duration</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.MotionPolicy.compute_joint_targets" title="Permalink to this definition"></a></dt>
<dd><p>Compute position and velocity targets for the next frame given the current robot state.
Position and velocity targets are used in Isaac Sim to generate forces using the PD equation
kp*(joint_position_targets-joint_positions) + kd*(joint_velocity_targets-joint_velocities).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>active_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_active_joints()</p></li>
<li><p><strong>active_joint_velocities</strong> (<em>np.array</em>) – current velocities of joints specified by get_active_joints()</p></li>
<li><p><strong>watched_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_watched_joints()</p></li>
<li><p><strong>watched_joint_velocities</strong> (<em>np.array</em>) – current velocities of joints specified by get_watched_joints()</p></li>
<li><p><strong>frame_duration</strong> (<em>float</em>) – duration of the physics frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>joint position targets for the active robot joints for the next frame</p>
<p>joint velocity targets for the active robot joints for the next frame</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.MotionPolicy.get_active_joints">
<span class="sig-name descname"><span class="pre">get_active_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.MotionPolicy.get_active_joints" title="Permalink to this definition"></a></dt>
<dd><p>Active joints are directly controlled by this MotionPolicy</p>
<p>Some articulated robot joints may be ignored by some policies. E.g., the gripper of the Franka arm is not used
to follow targets, and the RMPflow config files excludes the joints in the gripper from the list of articulated
joints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>names of active joints.  The order of joints in this list determines the order in which a
MotionPolicy expects joint states to be specified in functions like compute_joint_targets(active_joint_positions,…)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.MotionPolicy.get_watched_joints">
<span class="sig-name descname"><span class="pre">get_watched_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.MotionPolicy.get_watched_joints" title="Permalink to this definition"></a></dt>
<dd><p>Watched joints are joints whose position/velocity matters to the MotionPolicy, but are not directly controlled.
e.g. A MotionPolicy may control a robot arm on a mobile robot.  The joint states in the rest of the robot directly affect the position of the arm, but they are not actively controlled by this MotionPolicy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Names of joints that are being watched by this MotionPolicy. The order of joints in this list determines the order in which a
MotionPolicy expects joint states to be specified in functions like compute_joint_targets(…,watched_joint_positions,…)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.MotionPolicy.set_cspace_target">
<span class="sig-name descname"><span class="pre">set_cspace_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.MotionPolicy.set_cspace_target" title="Permalink to this definition"></a></dt>
<dd><p>Set configuration space target for the robot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>active_joint_target</strong> (<em>np.array</em>) – Desired configuration for the robot as (m x 1) vector where m is the number of active
joints.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.MotionPolicy.set_end_effector_target">
<span class="sig-name descname"><span class="pre">set_end_effector_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.MotionPolicy.set_end_effector_target" title="Permalink to this definition"></a></dt>
<dd><p>Set end effector target.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_translation</strong> (<em>nd.array</em>) – Translation vector (3x1) for robot end effector.
Target translation should be specified in the same units as the USD stage, relative to the stage origin.</p></li>
<li><p><strong>target_orientation</strong> (<em>nd.array</em>) – Quaternion of desired rotation for robot end effector relative to USD stage global frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RmpFlow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_description_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">urdf_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmpflow_config_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_effector_frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum_substep_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_robot_state_updates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow" title="Permalink to this definition"></a></dt>
<dd><p>RMPflow is a real-time, reactive motion policy that smoothly guides a robot to task space targets while avoiding dynamic obstacles.
This class implements the MotionPolicy interface, as well as providing a number of RmpFlow-specific functions such as visualizing
the believed robot position and changing internal settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_description_path</strong> (<em>str</em>) – Path to a robot description yaml file</p></li>
<li><p><strong>urdf_path</strong> (<em>str</em>) – Path to robot urdf</p></li>
<li><p><strong>rmpflow_config_path</strong> (<em>str</em>) – Path to an rmpflow parameter yaml file</p></li>
<li><p><strong>end_effector_frame_name</strong> (<em>str</em>) – Name of the robot end effector frame (must be present in the robot urdf)</p></li>
<li><p><strong>maximum_substep_size</strong> (<em>float</em>) – <p>Maximum substep size [sec] that RmpFlow will use when internally integrating between steps of a simulation.  For stability and performance,
RmpFlow rolls out the robot actions at a higher framerate than Isaac Sim.  For example, while Isaac Sim may be running at 60 Hz, RmpFlow can be set to take internal
steps that are no larger than 1/300 seconds.  In this case, RmpFlow will perform 5 sub-steps every time it returns an action to the 60 Hz simulation.</p>
<p>In general, the maximum_substep_size argument should be at most 1/200.  Choosing a very small maximum_substep_size such as 1/1000 is unnecessary, as the resulting actions will not
significantly differ from a choice of 1/500, but it will internally require twice the steps to compute.</p>
</p></li>
<li><p><strong>ignore_robot_state_updates</strong> (<em>bool</em>) – Defaults to False.
If False: RmpFlow will set the internal robot state to match the arguments to compute_joint_targets().  When paired with ArticulationMotionPolicy, this means that RMPflow uses the simulated robot’s state at every frame.
If True: RmpFlow will roll out the robot state internally after it is initially specified in the first call to compute_joint_targets().</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_ignore_state_updates">
<span class="sig-name descname"><span class="pre">set_ignore_state_updates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ignore_robot_state_updates</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_ignore_state_updates" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific method; set an internal flag in RmpFlow: ignore_robot_state_updates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ignore_robot_state_updates</strong> (<em>bool</em>) – <dl class="simple">
<dt>If False:</dt><dd><p>RmpFlow will set the internal robot state to match the arguments to compute_joint_targets().
When paired with ArticulationMotionPolicy, this means that RMPflow uses the simulated robot’s state at every frame.</p>
</dd>
<dt>If True:</dt><dd><p>RmpFlow will roll out the robot state internally after it is initially specified in the first call to compute_joint_targets().
The caller may override this flag and directly change the internal robot state with RmpFlow.set_internal_robot_joint_states().</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_cspace_target">
<span class="sig-name descname"><span class="pre">set_cspace_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_targets</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_cspace_target" title="Permalink to this definition"></a></dt>
<dd><p>Set a cspace target for RmpFlow.  RmpFlow always has a cspace target, and setting a new cspace target does not override a position target.
RmpFlow uses the cspace target to help resolve null space behavior when a position target can be acheived in a variety of ways.
If the end effector target is explicitly set to None, RmpFlow will move the robot to the cspace target</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>active_joint_targets</strong> (<em>np.array</em>) – cspace position target for active joints in the robot</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.update_world">
<span class="sig-name descname"><span class="pre">update_world</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updated_obstacles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.update_world" title="Permalink to this definition"></a></dt>
<dd><p>Update the internal world state of Lula.
This function automatically tracks the positions of obstacles that have been added with add_obstacle()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>updated_obstacles</strong> (<em>List</em><em>[</em><em>core.objects</em><em>]</em><em>, </em><em>optional</em>) – Obstacles that have been added by add_obstacle() that need to be updated.
If not specified, all non-static obstacle positions will be updated.
If specified, only the obstacles that have been listed will have their positions updated</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.compute_joint_targets">
<span class="sig-name descname"><span class="pre">compute_joint_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_joint_velocities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watched_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watched_joint_velocities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_duration</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.compute_joint_targets" title="Permalink to this definition"></a></dt>
<dd><p>Compute robot joint targets for the next frame based on the current robot position.
RmpFlow will ignore active joint positions and velocities if it has been set to ignore_robot_state_updates
RmpFlow does not currently support watching joints that it is not actively controlling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>active_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_active_joints()</p></li>
<li><p><strong>active_joint_velocities</strong> (<em>np.array</em>) – current velocities of joints specified by get_active_joints()</p></li>
<li><p><strong>watched_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_watched_joints()
This will always be empty for RmpFlow.</p></li>
<li><p><strong>watched_joint_velocities</strong> (<em>np.array</em>) – current velocities of joints specified by get_watched_joints()
This will always be empty for RmpFlow.</p></li>
<li><p><strong>frame_duration</strong> (<em>float</em>) – duration of the physics frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>active_joint_position_targets : Position targets for the robot in the next frame</p>
<p>active_joint_velocity_targets : Velocity targets for the robot in the next frame</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.visualize_collision_spheres">
<span class="sig-name descname"><span class="pre">visualize_collision_spheres</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.visualize_collision_spheres" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific debugging method.  This function creates visible sphere prims that match the locations and radii
of the collision spheres that RmpFlow uses to prevent robot collisions.  Once created, RmpFlow will update the sphere locations
whenever its internal robot state changes.  This can be used alongside RmpFlow.ignore_robot_state_updates(True) to validate RmpFlow’s
internal representation of the robot as well as help tune the PD gains on the simulated robot; i.e. the simulated robot should
match the positions of the RmpFlow collision spheres over time.</p>
<p>Visualizing collision spheres as prims on the stage is likely to significantly slow down the framerate of the simulation.  This function should only be used for debugging purposes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.visualize_end_effector_position">
<span class="sig-name descname"><span class="pre">visualize_end_effector_position</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.visualize_end_effector_position" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific debugging method.  This function creates a visible cube whose translation and orientation match where RmpFlow
believes the robot end effector to be.  Once created, RmpFlow will update the position of the cube whenever its internal robot state changes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.stop_visualizing_collision_spheres">
<span class="sig-name descname"><span class="pre">stop_visualizing_collision_spheres</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.stop_visualizing_collision_spheres" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific debugging method.  This function removes the collision sphere prims created by either RmpFlow.visualize_collision_spheres() or
RmpFlow.get_collision_spheres_as_prims().  Rather than making the prims invisible, they are deleted from the stage to increase performance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.stop_visualizing_end_effector">
<span class="sig-name descname"><span class="pre">stop_visualizing_end_effector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.stop_visualizing_end_effector" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific debugging method.  This function removes the end effector prim that can be created by visualize_end_effector_position() or
get_end_effector_position_as_prim()</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_collision_spheres_as_prims">
<span class="sig-name descname"><span class="pre">get_collision_spheres_as_prims</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_collision_spheres_as_prims" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific debugging method.  This function is similar to RmpFlow.visualize_collision_spheres().  If the collision spheres have already been added to the stage as prims,
they will be returned.  If the collision spheres have not been added to the stage as prims, they will be created and returned.  If created in this function, the spheres will be invisible
until RmpFlow.visualize_collision_spheres() is called.</p>
<p>Visualizing collision spheres on the stage is likely to significantly slow down the framerate of the simulation.  This function should only be used for debugging purposes</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List of prims representing RmpFlow’s internal collision spheres</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>collision_spheres (List[<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualSphere" title="omni.isaac.core.objects.sphere.VisualSphere">core.objects.sphere.VisualSphere</a>])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_end_effector_as_prim">
<span class="sig-name descname"><span class="pre">get_end_effector_as_prim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCuboid" title="omni.isaac.core.objects.cuboid.VisualCuboid"><span class="pre">omni.isaac.core.objects.cuboid.VisualCuboid</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_end_effector_as_prim" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific debugging method.  This function is similar to RmpFlow.visualize_end_effector_position().  If the end effector has already been visualized as a prim,
it will be returned.  If the end effector is not being visualized, a cuboid will be created and returned.  If created in this function, the end effector will be invisible
until RmpFlow.visualize_end_effector_position() is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Cuboid whose translation and orientation match RmpFlow’s believed robot end effector position.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>end_effector_prim (<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCuboid" title="omni.isaac.core.objects.cuboid.VisualCuboid">objects.cuboid.VisualCuboid</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.delete_collision_sphere_prims">
<span class="sig-name descname"><span class="pre">delete_collision_sphere_prims</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.delete_collision_sphere_prims" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific debugging method.  This function deletes any prims that have been created by RmpFlow to visualize its internal collision spheres</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.delete_end_effector_prim">
<span class="sig-name descname"><span class="pre">delete_end_effector_prim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.delete_end_effector_prim" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific debugging method.  If RmpFlow is maintaining a prim for its believed end effector position, this function will delete the prim.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.reset" title="Permalink to this definition"></a></dt>
<dd><p>Reset RmpFlow to its initial state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_internal_robot_joint_states">
<span class="sig-name descname"><span class="pre">set_internal_robot_joint_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_joint_velocities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watched_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watched_joint_velocities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_internal_robot_joint_states" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific method; this function overwrites the robot state regardless of the ignore_robot_state_updates flag.
RmpFlow does not currently support watching joints that it is not actively controlling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>active_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_active_joints()</p></li>
<li><p><strong>active_joint_velocities</strong> (<em>np.array</em>) – current velocities of joints specified by get_active_joints()</p></li>
<li><p><strong>watched_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_watched_joints().
This will always be empty for RmpFlow.</p></li>
<li><p><strong>watched_joint_velocities</strong> (<em>np.array</em>) – current velocities of joints specified by get_watched_joints()
This will always be empty for RmpFlow.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_internal_robot_joint_states">
<span class="sig-name descname"><span class="pre">get_internal_robot_joint_states</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_internal_robot_joint_states" title="Permalink to this definition"></a></dt>
<dd><p>An RmpFlow specific method; this function returns the internal robot state that is believed by RmpFlow</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>active_joint_positions: believed positions of active joints</p>
<p>active_joint_velocities: believed velocities of active joints</p>
<p>watched_joint_positions: believed positions of watched robot joints.  This will always be empty for RmpFlow.</p>
<p>watched_joint_velocities: believed velocities of watched robot joints.  This will always be empty for RmpFlow.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Tuple[np.array,np.array,np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_default_cspace_position_target">
<span class="sig-name descname"><span class="pre">get_default_cspace_position_target</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_default_cspace_position_target" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>An RmpFlow specific method; this function returns the default cspace position specified in the</dt><dd><p>Lula robot_description YAML file</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Default cspace position target used by RMPflow when none is specified.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_active_joints">
<span class="sig-name descname"><span class="pre">get_active_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_active_joints" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of joint names that RmpFlow is controlling.</p>
<p>Some articulated robot joints may be ignored by some policies. E.g., the gripper of the Franka arm is not used
to follow targets, and the RmpFlow config files excludes the joints in the gripper from the list of active
joints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>Names of active joints.</dt><dd><p>The order of the joints in this list matches the order that the joints are expected
in functions like RmpFlow.compute_joint_targets(active_joint_positions, active_joint_velocities,…)</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>active_joints (List[str])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_watched_joints">
<span class="sig-name descname"><span class="pre">get_watched_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_watched_joints" title="Permalink to this definition"></a></dt>
<dd><p>Currently, RmpFlow is not capable of watching joint states that are not being directly controlled (active joints)
If RmpFlow is controlling a robot arm at the end of an externally controlled body, set_robot_base_pose() can be used to make RmpFlow aware of the robot position
This means that RmpFlow is not currently able to support controlling a set of DOFs in a robot that are not sequentially linked to each other or are not connected
via fixed transforms to the end effector.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Empty list</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>watched_joints (List[str])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_end_effector_pose">
<span class="sig-name descname"><span class="pre">get_end_effector_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_end_effector_pose" title="Permalink to this definition"></a></dt>
<dd><p>Return pose of robot end effector given current joint positions.
The end effector position will be transformed into world coordinates based
on the believed position of the robot base.  See set_robot_base_pose()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>active_joint_positions</strong> (<em>np.array</em>) – positions of the active joints in the robot</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>end_effector_translation: (3x1) translation vector for the robot end effector</dt><dd><p>relative to the USD stage origin</p>
</dd>
<dt>end_effector_rotation: (3x3) rotation matrix describing the orientation of the</dt><dd><p>robot end effector relative to the USD global frame</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_kinematics_solver">
<span class="sig-name descname"><span class="pre">get_kinematics_solver</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.LulaKinematicsSolver" title="omni.isaac.motion_generation.lula.kinematics.LulaKinematicsSolver"><span class="pre">omni.isaac.motion_generation.lula.kinematics.LulaKinematicsSolver</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.get_kinematics_solver" title="Permalink to this definition"></a></dt>
<dd><p>Return a LulaKinematicsSolver that uses the same robot description as RmpFlow.  The robot base pose of the LulaKinematicsSolver
will be set to the same base pose as RmpFlow, but the two objects must then have their base poses updated separately.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Kinematics solver using the same cspace as RmpFlow</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#omni.isaac.motion_generation.LulaKinematicsSolver" title="omni.isaac.motion_generation.LulaKinematicsSolver">LulaKinematicsSolver</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_end_effector_target">
<span class="sig-name descname"><span class="pre">set_end_effector_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_end_effector_target" title="Permalink to this definition"></a></dt>
<dd><p>Set end effector target.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_translation</strong> (<em>nd.array</em>) – Translation vector (3x1) for robot end effector.
Target translation should be specified in the same units as the USD stage, relative to the stage origin.</p></li>
<li><p><strong>target_orientation</strong> (<em>nd.array</em>) – Quaternion of desired rotation for robot end effector relative to USD stage global frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_robot_base_pose">
<span class="sig-name descname"><span class="pre">set_robot_base_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robot_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.set_robot_base_pose" title="Permalink to this definition"></a></dt>
<dd><p>Update position of the robot base. Until this function is called, Lula will assume the base pose
to be at the origin with identity rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_position</strong> (<em>np.array</em>) – (3 x 1) translation vector describing the translation of the robot base relative to the USD stage origin.
The translation vector should be specified in the units of the USD stage</p></li>
<li><p><strong>robot_orientation</strong> (<em>np.array</em>) – (4 x 1) quaternion describing the orientation of the robot base relative to the USD stage global frame</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_obstacle">
<span class="sig-name descname"><span class="pre">add_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Add an obstacle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obstacle</strong> (<em>omni.isaac.core.objects</em>) – An obstacle from the package omni.isaac.core.obstacles
The type of the obstacle will be checked, and the appropriate add function will be called</p></li>
<li><p><strong>static</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – When True, the obstacle will be assumed to remain stationary relative to the USD global frame over time</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns True if the obstacle type is valid and the appropriate add function has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>success (bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_cuboid">
<span class="sig-name descname"><span class="pre">add_cuboid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cuboid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicCuboid" title="omni.isaac.core.objects.cuboid.DynamicCuboid"><span class="pre">omni.isaac.core.objects.cuboid.DynamicCuboid</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.FixedCuboid" title="omni.isaac.core.objects.cuboid.FixedCuboid"><span class="pre">omni.isaac.core.objects.cuboid.FixedCuboid</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCuboid" title="omni.isaac.core.objects.cuboid.VisualCuboid"><span class="pre">omni.isaac.core.objects.cuboid.VisualCuboid</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_cuboid" title="Permalink to this definition"></a></dt>
<dd><p>Add a block obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cuboid</strong> (<em>core.objects.cuboid</em>) – Wrapper object for handling rectangular prism Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that cuboid will never change pose, and may be ignored in internal
world updates. Since Lula specifies object positions relative to the robot’s frame
of reference, static obstacles will have their positions queried any time that
set_robot_base_pose() is called.  Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Always True, indicating that this adder has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_sphere">
<span class="sig-name descname"><span class="pre">add_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicSphere" title="omni.isaac.core.objects.sphere.DynamicSphere"><span class="pre">omni.isaac.core.objects.sphere.DynamicSphere</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualSphere" title="omni.isaac.core.objects.sphere.VisualSphere"><span class="pre">omni.isaac.core.objects.sphere.VisualSphere</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_sphere" title="Permalink to this definition"></a></dt>
<dd><p>Add a sphere obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sphere</strong> (<em>core.objects.sphere</em>) – Wrapper object for handling sphere Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that sphere will never change pose, and may be ignored in internal
world updates. Since Lula specifies object positions relative to the robot’s frame
of reference, static obstacles will have their positions queried any time that
set_robot_base_pose() is called.  Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Always True, indicating that this adder has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_capsule">
<span class="sig-name descname"><span class="pre">add_capsule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">capsule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicCapsule" title="omni.isaac.core.objects.capsule.DynamicCapsule"><span class="pre">omni.isaac.core.objects.capsule.DynamicCapsule</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCapsule" title="omni.isaac.core.objects.capsule.VisualCapsule"><span class="pre">omni.isaac.core.objects.capsule.VisualCapsule</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_capsule" title="Permalink to this definition"></a></dt>
<dd><p>Add a capsule obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>capsule</strong> (<em>core.objects.capsule</em>) – Wrapper object for handling capsule Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that capsule will never change pose, and may be ignored in internal
world updates. Since Lula specifies object positions relative to the robot’s frame
of reference, static obstacles will have their positions queried any time that
set_robot_base_pose() is called.  Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Always True, indicating that this function has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_ground_plane">
<span class="sig-name descname"><span class="pre">add_ground_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_plane</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.GroundPlane" title="omni.isaac.core.objects.ground_plane.GroundPlane"><span class="pre">omni.isaac.core.objects.ground_plane.GroundPlane</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.add_ground_plane" title="Permalink to this definition"></a></dt>
<dd><p>Add a ground_plane.
Lula does not support ground planes directly, and instead internally creates a cuboid with an
expansive face (dimensions 200x200 stage units) coplanar to the ground_plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ground_plane</strong> (<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.GroundPlane" title="omni.isaac.core.objects.ground_plane.GroundPlane"><em>core.objects.ground_plane.GroundPlane</em></a>) – Wrapper object for handling ground_plane Usd Prims.</p></li>
<li><p><strong>plane_width</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – The width of the ground plane (in meters) that Lula creates to constrain this robot.  Defaults to 50.0 m</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Always True, indicating that this adder has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.disable_obstacle">
<span class="sig-name descname"><span class="pre">disable_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.disable_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Disable collision avoidance for obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.objects</em>) – obstacle to be disabled.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully disabled.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.enable_obstacle">
<span class="sig-name descname"><span class="pre">enable_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.enable_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Enable collision avoidance for obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.objects</em>) – obstacle to be enabled.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully enabled.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.motion_policies.RmpFlow.remove_obstacle">
<span class="sig-name descname"><span class="pre">remove_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.motion_policies.RmpFlow.remove_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Remove obstacle from collision avoidance. Obstacle cannot be re-enabled via enable_obstacle() after
removal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.objects</em>) – obstacle to be removed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully removed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="articulationmotionpolicy">
<h2>ArticulationMotionPolicy<a class="headerlink" href="#articulationmotionpolicy" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ArticulationMotionPolicy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_articulation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.articulation.Articulation"><span class="pre">omni.isaac.core.articulations.articulation.Articulation</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">motion_policy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#omni.isaac.motion_generation.MotionPolicy" title="omni.isaac.motion_generation.motion_policy_interface.MotionPolicy"><span class="pre">omni.isaac.motion_generation.motion_policy_interface.MotionPolicy</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_physics_dt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.016666666666666666</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper class for running MotionPolicy on simulated robots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_articulation</strong> (<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.Articulation"><em>Articulation</em></a>) – an initialized robot Articulation object</p></li>
<li><p><strong>motion_policy</strong> (<a class="reference internal" href="#omni.isaac.motion_generation.MotionPolicy" title="omni.isaac.motion_generation.MotionPolicy"><em>MotionPolicy</em></a>) – an instance of a class that implements the MotionPolicy interface</p></li>
<li><p><strong>default_physics_dt</strong> (<em>float</em>) – Default physics step size to use when computing actions. A MotionPolicy computes a target
position/velocity for the next frame of the simulation using the provided physics dt to know how far in the future that will be.
Isaac Sim can be run with a constant or variable physics framerate.
When not specified on an individual frame, the dt of the frame is assumed
to be the provided default value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy.move">
<span class="sig-name descname"><span class="pre">move</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">physics_dt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy.move" title="Permalink to this definition"></a></dt>
<dd><p>Use underlying MotionPolicy to compute and apply joint targets to the robot over the next frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>physics_dt</strong> (<em>float</em>) – Physics dt to use on this frame to calculate the next action.  This overrides
the default_physics_dt argument, but does not change the default on future calls.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy.get_next_articulation_action">
<span class="sig-name descname"><span class="pre">get_next_articulation_action</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">physics_dt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction"><span class="pre">omni.isaac.core.utils.types.ArticulationAction</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy.get_next_articulation_action" title="Permalink to this definition"></a></dt>
<dd><p>Use underlying MotionPolicy to compute joint targets for the robot over the next frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>physics_dt</strong> (<em>float</em>) – Physics dt to use on this frame to calculate the next action.  This overrides
the default_physics_dt argument, but does not change the default on future calls.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Desired position/velocity target for the robot in the next frame</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction">ArticulationAction</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy.get_active_joints_subset">
<span class="sig-name descname"><span class="pre">get_active_joints_subset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.ArticulationSubset" title="omni.isaac.core.articulations.articulation_subset.ArticulationSubset"><span class="pre">omni.isaac.core.articulations.articulation_subset.ArticulationSubset</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy.get_active_joints_subset" title="Permalink to this definition"></a></dt>
<dd><p>Get view into active joints</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>returns robot states for active joints in an order compatible with the MotionPolicy</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.ArticulationSubset" title="omni.isaac.core.articulations.ArticulationSubset">ArticulationSubset</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy.get_watched_joints_subset">
<span class="sig-name descname"><span class="pre">get_watched_joints_subset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.ArticulationSubset" title="omni.isaac.core.articulations.articulation_subset.ArticulationSubset"><span class="pre">omni.isaac.core.articulations.articulation_subset.ArticulationSubset</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy.get_watched_joints_subset" title="Permalink to this definition"></a></dt>
<dd><p>Get view into watched joints</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>returns robot states for watched joints in an order compatible with the MotionPolicy</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.ArticulationSubset" title="omni.isaac.core.articulations.ArticulationSubset">ArticulationSubset</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy.get_robot_articulation">
<span class="sig-name descname"><span class="pre">get_robot_articulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.articulation.Articulation"><span class="pre">omni.isaac.core.articulations.articulation.Articulation</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy.get_robot_articulation" title="Permalink to this definition"></a></dt>
<dd><p>Get the underlying Articulation object representing the robot.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Articulation object representing the robot.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.Articulation">Articulation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy.get_motion_policy">
<span class="sig-name descname"><span class="pre">get_motion_policy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.MotionPolicy" title="omni.isaac.motion_generation.motion_policy_interface.MotionPolicy"><span class="pre">omni.isaac.motion_generation.motion_policy_interface.MotionPolicy</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy.get_motion_policy" title="Permalink to this definition"></a></dt>
<dd><p>Get MotionPolicy that is being used to compute ArticulationActions</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>MotionPolicy being used to compute ArticulationActions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#omni.isaac.motion_generation.MotionPolicy" title="omni.isaac.motion_generation.MotionPolicy">MotionPolicy</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy.get_default_physics_dt">
<span class="sig-name descname"><span class="pre">get_default_physics_dt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy.get_default_physics_dt" title="Permalink to this definition"></a></dt>
<dd><p>Get the default value of the physics dt that is used to compute actions when none is provided</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Default physics dt</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationMotionPolicy.set_default_physics_dt">
<span class="sig-name descname"><span class="pre">set_default_physics_dt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">physics_dt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationMotionPolicy.set_default_physics_dt" title="Permalink to this definition"></a></dt>
<dd><p>Set the default value of the physics dt that is used to compute actions when none is provided</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>physics_dt</strong> (<em>float</em>) – Default physics dt</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="kinematicssolver">
<h2>KinematicsSolver<a class="headerlink" href="#kinematicssolver" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.KinematicsSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">KinematicsSolver</span></span><a class="headerlink" href="#omni.isaac.motion_generation.KinematicsSolver" title="Permalink to this definition"></a></dt>
<dd><p>An limitted interface for computing robot kinematics that includes forward and inverse kinematics.
This interface ommits more advanced kinematics such as Jacobians, as they are not required for most use-cases.</p>
<p>This interface inherits from the WorldInterface to standardize the inputs to collision-aware IK solvers, but it is not necessary for
all implementations to implement the WorldInterface.  See KinematicsSolver.supports_collision_avoidance()</p>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.KinematicsSolver.set_robot_base_pose">
<span class="sig-name descname"><span class="pre">set_robot_base_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robot_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.KinematicsSolver.set_robot_base_pose" title="Permalink to this definition"></a></dt>
<dd><p>Update position of the robot base. This will be used to compute kinematics relative to the USD stage origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_positions</strong> (<em>np.array</em>) – (3 x 1) translation vector describing the translation of the robot base relative to the USD stage origin.
The translation vector should be specified in the units of the USD stage</p></li>
<li><p><strong>robot_orientation</strong> (<em>np.array</em>) – (4 x 1) quaternion describing the orientation of the robot base relative to the USD stage global frame</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.KinematicsSolver.get_joint_names">
<span class="sig-name descname"><span class="pre">get_joint_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.KinematicsSolver.get_joint_names" title="Permalink to this definition"></a></dt>
<dd><p>Return a list containing the names of all joints in the given kinematic structure.  The order of this list
determines the order in which the joint positions are expected in compute_forward_kinematics(joint_positions,…) and
the order in which they are returned in compute_inverse_kinematics()</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Names of all joints in the robot</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.KinematicsSolver.get_all_frame_names">
<span class="sig-name descname"><span class="pre">get_all_frame_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.KinematicsSolver.get_all_frame_names" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of all the frame names in the given kinematic structure</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All frame names in the kinematic structure.  Any of which can be used to compute forward or inverse kinematics.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.KinematicsSolver.compute_forward_kinematics">
<span class="sig-name descname"><span class="pre">compute_forward_kinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position_only</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.KinematicsSolver.compute_forward_kinematics" title="Permalink to this definition"></a></dt>
<dd><p>Compute the position of a given frame in the robot relative to the USD stage global frame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_name</strong> (<em>str</em>) – Name of robot frame on which to calculate forward kinematics</p></li>
<li><p><strong>joint_positions</strong> (<em>np.array</em>) – Joint positions for the joints returned by get_joint_names()</p></li>
<li><p><strong>position_only</strong> (<em>bool</em>) – If True, only the frame positions need to be calculated and the returned rotation may be left undefined.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>frame_positions: (3x1) vector describing the translation of the frame relative to the USD stage origin</p>
<p>frame_rotation: (3x3) rotation matrix describing the rotation of the frame relative to the USD stage global frame</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.KinematicsSolver.compute_inverse_kinematics">
<span class="sig-name descname"><span class="pre">compute_inverse_kinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warm_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.KinematicsSolver.compute_inverse_kinematics" title="Permalink to this definition"></a></dt>
<dd><p>Compute joint positions such that the specified robot frame will reach the desired translations and rotations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_name</strong> (<em>str</em>) – name of the target frame for inverse kinematics</p></li>
<li><p><strong>target_position</strong> (<em>np.array</em>) – target translation of the target frame (in stage units) relative to the USD stage origin</p></li>
<li><p><strong>target_orientation</strong> (<em>np.array</em>) – target orientation of the target frame relative to the USD stage global frame. Defaults to None.</p></li>
<li><p><strong>warm_start</strong> (<em>np.array</em>) – a starting position that will be used when solving the IK problem. Defaults to None.</p></li>
<li><p><strong>position_tolerance</strong> (<em>float</em>) – l-2 norm of acceptable position error (in stage units) between the target and achieved translations. Defaults to None.</p></li>
<li><p><strong>tolerance</strong> (<em>orientation</em>) – magnitude of rotation (in radians) separating the target orientation from the achieved orienatation.
orientation_tolerance is well defined for values between 0 and pi. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>joint_positions: in the order specified by get_joint_names() which result in the target frame acheiving the desired position</p>
<p>success: True if the solver converged to a solution within the given tolerances</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,bool]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.KinematicsSolver.supports_collision_avoidance">
<span class="sig-name descname"><span class="pre">supports_collision_avoidance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.KinematicsSolver.supports_collision_avoidance" title="Permalink to this definition"></a></dt>
<dd><p>Returns a bool describing whether the inverse kinematics support collision avoidance. If the policy does not support collision
avoidance, none of the obstacle add/remove/enable/disable functions need to be implemented.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>If True, the IK solver will avoid any obstacles that have been added</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LulaKinematicsSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_description_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">urdf_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robot_description</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.lula/docs/index.html#lula.RobotDescription" title="lula.RobotDescription"><span class="pre">lula.RobotDescription</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver" title="Permalink to this definition"></a></dt>
<dd><p>A Lula-based implementaion of the KinematicsSolver interface.  Lula uses a URDF file describing the robot and
a custom yaml file that specifies the cspace of the robot and other parameters.</p>
<p>This class provides functions beyond the specified interface for getting and setting solver parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_description_path</strong> (<em>str</em>) – path to a robot description yaml file describing the cspace of the robot and other relevant parameters</p></li>
<li><p><strong>urdf_path</strong> (<em>str</em>) – path to a URDF file describing the robot</p></li>
<li><p><strong>robot_description</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../../omni.isaac.lula/docs/index.html#lula.RobotDescription" title="lula.RobotDescription"><em>lula.RobotDescription</em></a><em>]</em>) – An initialized lula.RobotDescription object.  Other Lula-based classes such as RmpFlow may use
a lula.RobotDescription object that they have already created to initialize a LulaKinematicsSolver.  When specified, the provided file paths are unused.
Defaults to None.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.set_robot_base_pose">
<span class="sig-name descname"><span class="pre">set_robot_base_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robot_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.set_robot_base_pose" title="Permalink to this definition"></a></dt>
<dd><p>Update position of the robot base. This will be used to compute kinematics relative to the USD stage origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_positions</strong> (<em>np.array</em>) – (3 x 1) translation vector describing the translation of the robot base relative to the USD stage origin.
The translation vector should be specified in the units of the USD stage</p></li>
<li><p><strong>robot_orientation</strong> (<em>np.array</em>) – (4 x 1) quaternion describing the orientation of the robot base relative to the USD stage global frame</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_joint_names">
<span class="sig-name descname"><span class="pre">get_joint_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_joint_names" title="Permalink to this definition"></a></dt>
<dd><p>Return a list containing the names of all joints in the given kinematic structure.  The order of this list
determines the order in which the joint positions are expected in compute_forward_kinematics(joint_positions,…) and
the order in which they are returned in compute_inverse_kinematics()</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Names of all joints in the robot</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_all_frame_names">
<span class="sig-name descname"><span class="pre">get_all_frame_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_all_frame_names" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of all the frame names in the given kinematic structure</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>All frame names in the kinematic structure.  Any of which can be used to compute forward or inverse kinematics.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.compute_forward_kinematics">
<span class="sig-name descname"><span class="pre">compute_forward_kinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position_only</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.compute_forward_kinematics" title="Permalink to this definition"></a></dt>
<dd><p>Compute the position of a given frame in the robot relative to the USD stage global frame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_name</strong> (<em>str</em>) – Name of robot frame on which to calculate forward kinematics</p></li>
<li><p><strong>joint_positions</strong> (<em>np.array</em>) – Joint positions for the joints returned by get_joint_names()</p></li>
<li><p><strong>position_only</strong> (<em>bool</em>) – Lula Kinematics ignore this flag and always computes both position and orientation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>frame_positions: (3x1) vector describing the translation of the frame relative to the USD stage origin</p>
<p>frame_rotation: (3x3) rotation matrix describing the rotation of the frame relative to the USD stage global frame</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.compute_inverse_kinematics">
<span class="sig-name descname"><span class="pre">compute_inverse_kinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warm_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.compute_inverse_kinematics" title="Permalink to this definition"></a></dt>
<dd><p>Compute joint positions such that the specified robot frame will reach the desired translations and rotations.
Lula Kinematics interpret the orientation tolerance as being the maximum rotation separating any standard axes.
e.g. For a tolerance of .1: The X axes, Y axes, and Z axes of the rotation matrices may independently be as far as .1 radians apart</p>
<p>Default values for position and orientation tolerances may be seen and changed with setter and getter functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_name</strong> (<em>str</em>) – name of the target frame for inverse kinematics</p></li>
<li><p><strong>target_position</strong> (<em>np.array</em>) – target translation of the target frame (in stage units) relative to the USD stage origin</p></li>
<li><p><strong>target_orientation</strong> (<em>np.array</em>) – target orientation of the target frame relative to the USD stage global frame. Defaults to None.</p></li>
<li><p><strong>warm_start</strong> (<em>np.array</em>) – a starting position that will be used when solving the IK problem.  If default cspace seeds have been set,
the warm start will be given priority, but the default seeds will still be used. Defaults to None.</p></li>
<li><p><strong>position_tolerance</strong> (<em>float</em>) – l-2 norm of acceptable position error (in stage units) between the target and achieved translations. Defaults to None.</p></li>
<li><p><strong>tolerance</strong> (<em>orientation</em>) – magnitude of rotation (in radians) separating the target orientation from the achieved orienatation.
orientation_tolerance is well defined for values between 0 and pi.  Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>joint_positions: in the order specified by get_joint_names() which result in the target frame acheiving the desired position</p>
<p>success: True if the solver converged to a solution within the given tolerances</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,bool]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.supports_collision_avoidance">
<span class="sig-name descname"><span class="pre">supports_collision_avoidance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.supports_collision_avoidance" title="Permalink to this definition"></a></dt>
<dd><p>Lula Inverse Kinematics do not support collision avoidance with USD obstacles</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Always False</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.set_orientation_weight">
<span class="sig-name descname"><span class="pre">set_orientation_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.set_orientation_weight" title="Permalink to this definition"></a></dt>
<dd><p>Orientation weight describes a ratio of importance betwee hitting the position and orientation target.
A weight of 0 implies that the solver cares only about the orientation target.  When no orientation target is given
to compute_inverse_kinematics(), a weight of 0 is automatically used over the default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>weight</strong> (<em>float</em>) – Ratio describing the relative importance of the orientation target vs. the position target when solving IK</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.set_default_orientation_tolerance">
<span class="sig-name descname"><span class="pre">set_default_orientation_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.set_default_orientation_tolerance" title="Permalink to this definition"></a></dt>
<dd><p>Default orientation tolerance to be used when calculating IK when none is specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tolerance</strong> (<em>float</em>) – magnitude of rotation (in radians) separating the target orientation from the achieved orienatation.
orientation_tolerance is well defined for values between 0 and pi.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.set_default_position_tolerance">
<span class="sig-name descname"><span class="pre">set_default_position_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.set_default_position_tolerance" title="Permalink to this definition"></a></dt>
<dd><p>Default position tolerance to be used when calculating IK when none is specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tolerance</strong> (<em>float</em>) – l-2 norm of acceptable position error (in stage units) between the target and achieved translations</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.set_max_iterations">
<span class="sig-name descname"><span class="pre">set_max_iterations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.set_max_iterations" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum number of iterations that the IK solver will attempt before giving up</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_iterations</strong> (<em>int</em>) – maximum number of iterations that the IK solver will attempt before giving up</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.set_descent_termination_delta">
<span class="sig-name descname"><span class="pre">set_descent_termination_delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.set_descent_termination_delta" title="Permalink to this definition"></a></dt>
<dd><p>Set the minimum delta between two solutions at which the IK solver may terminate due to the solution not improving anymore</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>delta</strong> (<em>float</em>) – minimum delta between two solutions at which the IK solver may terminate due to the solution not improving anymore</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.set_default_cspace_seeds">
<span class="sig-name descname"><span class="pre">set_default_cspace_seeds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.set_default_cspace_seeds" title="Permalink to this definition"></a></dt>
<dd><p>Set a list of cspace seeds that the solver may use as starting points for solutions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seeds</strong> (<em>np.array</em>) – An N x num_dof list of cspace seeds</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_orientation_weight">
<span class="sig-name descname"><span class="pre">get_orientation_weight</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_orientation_weight" title="Permalink to this definition"></a></dt>
<dd><p>Orientation weight describes a ratio of importance betwee hitting the position and orientation target.
A weight of 0 implies that the solver cares only about the orientation target.  When no orientation target is given
to compute_inverse_kinematics(), a weight of 0 is automatically used over the default.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Ratio describing the relative importance of the orientation target vs. the position target when solving IK</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_default_orientation_tolerance">
<span class="sig-name descname"><span class="pre">get_default_orientation_tolerance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_default_orientation_tolerance" title="Permalink to this definition"></a></dt>
<dd><p>Get the default orientation tolerance to be used when calculating IK when none is specified</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>magnitude of rotation (in radians) separating the target orientation from the achieved orienatation.</dt><dd><p>orientation_tolerance is well defined for values between 0 and pi.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_default_position_tolerance">
<span class="sig-name descname"><span class="pre">get_default_position_tolerance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_default_position_tolerance" title="Permalink to this definition"></a></dt>
<dd><p>Get the default position tolerance to be used when calculating IK when none is specified</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>l-2 norm of acceptable position error (in stage units) between the target and achieved translations</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_max_iterations">
<span class="sig-name descname"><span class="pre">get_max_iterations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_max_iterations" title="Permalink to this definition"></a></dt>
<dd><p>Get the maximum number of iterations that the IK solver will attempt before giving up</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>maximum number of iterations that the IK solver will attempt before giving up</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_descent_termination_delta">
<span class="sig-name descname"><span class="pre">get_descent_termination_delta</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_descent_termination_delta" title="Permalink to this definition"></a></dt>
<dd><p>Get the minimum delta between two solutions at which the IK solver may terminate due to the solution not improving anymore</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>minimum delta between two solutions at which the IK solver may terminate due to the solution not improving anymore</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_default_cspace_seeds">
<span class="sig-name descname"><span class="pre">get_default_cspace_seeds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_default_cspace_seeds" title="Permalink to this definition"></a></dt>
<dd><p>Get a list of cspace seeds that the solver may use as starting points for solutions</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An N x num_dof list of cspace seeds</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_cspace_position_limits">
<span class="sig-name descname"><span class="pre">get_cspace_position_limits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_cspace_position_limits" title="Permalink to this definition"></a></dt>
<dd><p>Get the default upper and lower joint limits of the active joints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>default_lower_joint_position_limits : Default lower position limits of active joints</p>
<p>default_upper_joint_position_limits : Default upper position limits of active joints</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Tuple[np.array, np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_cspace_velocity_limits">
<span class="sig-name descname"><span class="pre">get_cspace_velocity_limits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.array</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_cspace_velocity_limits" title="Permalink to this definition"></a></dt>
<dd><p>Get the default velocity limits of the active joints</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Default velocity limits of the active joints</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_cspace_acceleration_limits">
<span class="sig-name descname"><span class="pre">get_cspace_acceleration_limits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.array</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_cspace_acceleration_limits" title="Permalink to this definition"></a></dt>
<dd><p>Get the default acceleration limits of the active joints.
Default acceleration limits are read from the robot_description YAML file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Default acceleration limits of the active joints</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.LulaKinematicsSolver.get_cspace_jerk_limits">
<span class="sig-name descname"><span class="pre">get_cspace_jerk_limits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.array</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.LulaKinematicsSolver.get_cspace_jerk_limits" title="Permalink to this definition"></a></dt>
<dd><p>Get the default jerk limits of the active joints.
Default jerk limits are read from the robot_description YAML file.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Default jerk limits of the active joints.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="articulationkinematicssolver">
<h2>ArticulationKinematicsSolver<a class="headerlink" href="#articulationkinematicssolver" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationKinematicsSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ArticulationKinematicsSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_articulation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.articulation.Articulation"><span class="pre">omni.isaac.core.articulations.articulation.Articulation</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">kinematics_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#omni.isaac.motion_generation.KinematicsSolver" title="omni.isaac.motion_generation.kinematics_interface.KinematicsSolver"><span class="pre">omni.isaac.motion_generation.kinematics_interface.KinematicsSolver</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_effector_frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationKinematicsSolver" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper class for computing robot kinematics in a way that is easily transferable to the simulated robot Articulation.  A KinematicsSolver
computes FK and IK at any frame, possibly only using a subset of joints available on the simulated robot.
This wrapper simplifies computing the current position of the simulated robot’s end effector, as well as wrapping an IK result in an ArticulationAction that is
recognized by the robot Articulation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_articulation</strong> (<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.Articulation"><em>Articulation</em></a>) – Initialized robot Articulation object representing the simulated USD robot</p></li>
<li><p><strong>kinematics_solver</strong> (<a class="reference internal" href="#omni.isaac.motion_generation.KinematicsSolver" title="omni.isaac.motion_generation.KinematicsSolver"><em>KinematicsSolver</em></a>) – An instance of a class that implements the KinematicsSolver</p></li>
<li><p><strong>end_effector_frame_name</strong> (<em>str</em>) – The name of the robot’s end effector frame.  This frame must appear in kinematics_solver.get_all_frame_names()</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationKinematicsSolver.compute_end_effector_pose">
<span class="sig-name descname"><span class="pre">compute_end_effector_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">position_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationKinematicsSolver.compute_end_effector_pose" title="Permalink to this definition"></a></dt>
<dd><p>Compute the pose of the robot end effector using the simulated robot’s current joint positions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>position_only</strong> (<em>bool</em>) – If True, only the frame positions need to be calculated.  The returned rotation may be left undefined.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>position: Translation vector describing the translation of the robot end effector relative to the USD global frame (in stage units)</p>
<p>rotation: (3x3) rotation matrix describing the rotation of the frame relative to the USD stage global frame</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationKinematicsSolver.compute_inverse_kinematics">
<span class="sig-name descname"><span class="pre">compute_inverse_kinematics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction"><span class="pre">omni.isaac.core.utils.types.ArticulationAction</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationKinematicsSolver.compute_inverse_kinematics" title="Permalink to this definition"></a></dt>
<dd><p>Compute inverse kinematics for the end effector frame using the current robot position as a warm start.  The result is returned
in an articulation action that can be directly applied to the robot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_position</strong> (<em>np.array</em>) – target translation of the target frame (in stage units) relative to the USD stage origin</p></li>
<li><p><strong>target_orientation</strong> (<em>np.array</em>) – target orientation of the target frame relative to the USD stage global frame. Defaults to None.</p></li>
<li><p><strong>position_tolerance</strong> (<em>float</em>) – l-2 norm of acceptable position error (in stage units) between the target and achieved translations. Defaults to None.</p></li>
<li><p><strong>tolerance</strong> (<em>orientation</em>) – magnitude of rotation (in radians) separating the target orientation from the achieved orienatation.
orientation_tolerance is well defined for values between 0 and pi. Defaults to None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>ik_result: An ArticulationAction that can be applied to the robot to move the end effector frame to the desired position.</p>
<p>success: Solver converged successfully</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction">ArticulationAction</a>, bool]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationKinematicsSolver.set_end_effector_frame">
<span class="sig-name descname"><span class="pre">set_end_effector_frame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">end_effector_frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationKinematicsSolver.set_end_effector_frame" title="Permalink to this definition"></a></dt>
<dd><p>Set the name for the end effector frame.  If the frame is not recognized by the internal KinematicsSolver instance, an error will be thrown</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>end_effector_frame_name</strong> (<em>str</em>) – Name of the robot end effector frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationKinematicsSolver.get_end_effector_frame">
<span class="sig-name descname"><span class="pre">get_end_effector_frame</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationKinematicsSolver.get_end_effector_frame" title="Permalink to this definition"></a></dt>
<dd><p>Get the end effector frame</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Name of the end effector frame</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationKinematicsSolver.get_joints_subset">
<span class="sig-name descname"><span class="pre">get_joints_subset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.ArticulationSubset" title="omni.isaac.core.articulations.articulation_subset.ArticulationSubset"><span class="pre">omni.isaac.core.articulations.articulation_subset.ArticulationSubset</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationKinematicsSolver.get_joints_subset" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A wrapper class for querying USD robot joint states in the order expected by the kinematics solver</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.ArticulationSubset" title="omni.isaac.core.articulations.ArticulationSubset">ArticulationSubset</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationKinematicsSolver.get_kinematics_solver">
<span class="sig-name descname"><span class="pre">get_kinematics_solver</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.KinematicsSolver" title="omni.isaac.motion_generation.kinematics_interface.KinematicsSolver"><span class="pre">omni.isaac.motion_generation.kinematics_interface.KinematicsSolver</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationKinematicsSolver.get_kinematics_solver" title="Permalink to this definition"></a></dt>
<dd><p>Get the underlying KinematicsSolver instance used by this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A class that can solve forward and inverse kinematics for a specified robot.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#omni.isaac.motion_generation.KinematicsSolver" title="omni.isaac.motion_generation.KinematicsSolver">KinematicsSolver</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="path-planning-interface">
<h2>Path Planning Interface<a class="headerlink" href="#path-planning-interface" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.PathPlanner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PathPlanner</span></span><a class="headerlink" href="#omni.isaac.motion_generation.PathPlanner" title="Permalink to this definition"></a></dt>
<dd><p>Interface for implementing a PathPlanner: An algorithm that outputs a series of configuration space waypoints, which
when linearly interpolated, produce a collision-free path from a starting c-space pose to a c-space or task-space target pose.</p>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.PathPlanner.set_robot_base_pose">
<span class="sig-name descname"><span class="pre">set_robot_base_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_translation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robot_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.PathPlanner.set_robot_base_pose" title="Permalink to this definition"></a></dt>
<dd><p>Set the position of the robot base. Computed paths will assume that the robot base remains stationary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_translation</strong> (<em>np.array</em>) – (3 x 1) translation vector describing the translation of the robot base relative to the USD stage origin.
The translation vector should be specified in the units of the USD stage</p></li>
<li><p><strong>robot_orientation</strong> (<em>np.array</em>) – (4 x 1) quaternion describing the orientation of the robot base relative to the USD stage global frame</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.PathPlanner.compute_path">
<span class="sig-name descname"><span class="pre">compute_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watched_joint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.array</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.PathPlanner.compute_path" title="Permalink to this definition"></a></dt>
<dd><p>Compute a set of c-space waypoints, which when linearly interpolated,
produce a collision-free path from a starting c-space pose to a c-space or task-space target pose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>active_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_active_joints()</p></li>
<li><p><strong>watched_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_watched_joints()</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>path: An (N x m) sequence of joint positions for the active joints in the robot where N is the path length and</dt><dd><p>m is the number of active joints in the robot.  If no plan is found, or no target positions have been set, None is returned</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.PathPlanner.get_active_joints">
<span class="sig-name descname"><span class="pre">get_active_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.PathPlanner.get_active_joints" title="Permalink to this definition"></a></dt>
<dd><p>Active joints are directly controlled by this PathPlanner</p>
<p>Some articulated robot joints may be ignored by some policies. E.g., the gripper of the Franka arm is not used
to follow targets, and the RMPflow config files excludes the joints in the gripper from the list of articulated
joints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>names of active joints.  The order of joints in this list determines the order in which a
PathPlanner expects joint states to be specified in functions like compute_path(active_joint_positions,…)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.PathPlanner.get_watched_joints">
<span class="sig-name descname"><span class="pre">get_watched_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.PathPlanner.get_watched_joints" title="Permalink to this definition"></a></dt>
<dd><p>Watched joints are joints whose position matters to the PathPlanner, but are not directly controlled.
e.g.  A robot may have a watched joint in the middle of its kinematic chain. Watched joints will be assumed
to remain watched during the rollout of a path.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Names of joints that are being watched by this PathPlanner. The order of joints in this list determines the order in which a
PathPlanner expects joint states to be specified in functions like compute_path(…,watched_joint_positions,…).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.PathPlanner.set_cspace_target">
<span class="sig-name descname"><span class="pre">set_cspace_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.PathPlanner.set_cspace_target" title="Permalink to this definition"></a></dt>
<dd><p>Set configuration space target for the robot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>active_joint_target</strong> (<em>np.array</em>) – Desired configuration for the robot as (m x 1) vector where m is the number of active
joints.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.PathPlanner.set_end_effector_target">
<span class="sig-name descname"><span class="pre">set_end_effector_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_translation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.PathPlanner.set_end_effector_target" title="Permalink to this definition"></a></dt>
<dd><p>Set end effector target.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_translation</strong> (<em>nd.array</em>) – Translation vector (3x1) for robot end effector.
Target translation should be specified in the same units as the USD stage, relative to the stage origin.</p></li>
<li><p><strong>target_orientation</strong> (<em>nd.array</em>) – Quaternion of desired rotation for robot end effector relative to USD stage global frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RRT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_description_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">urdf_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rrt_config_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_effector_frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT" title="Permalink to this definition"></a></dt>
<dd><p>RRT is a stochastic algorithm for quickly finding a feasible path in cspace to move a robot from a starting pose to a target pose.
This class implements the PathPlanner interface, as well as exposing RRT-specific parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_description_path</strong> (<em>str</em>) – path to a robot description yaml file</p></li>
<li><p><strong>urdf_path</strong> (<em>str</em>) – path to robot urdf</p></li>
<li><p><strong>rrt_config_path</strong> (<em>str</em>) – path to an rrt parameter yaml file</p></li>
<li><p><strong>end_effector_frame_name</strong> (<em>str</em>) – name of the robot end effector frame (must be present in the robot urdf)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.compute_path">
<span class="sig-name descname"><span class="pre">compute_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">watched_joint_positions</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.array</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.compute_path" title="Permalink to this definition"></a></dt>
<dd><p>Compute a set of c-space waypoints, which when linearly interpolated,
produce a collision-free path from a starting c-space pose to a c-space or task-space target pose.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>active_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_active_joints()</p></li>
<li><p><strong>watched_joint_positions</strong> (<em>np.array</em>) – current positions of joints specified by get_watched_joints()</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>path: An (N x m) sequence of joint positions for the active joints in the robot where N is the path length and</dt><dd><p>m is the number of active joints in the robot.  If no plan is found, or no target positions have been set, None is returned</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array or None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.set_robot_base_pose">
<span class="sig-name descname"><span class="pre">set_robot_base_pose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">robot_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.set_robot_base_pose" title="Permalink to this definition"></a></dt>
<dd><p>Update position of the robot base. Until this function is called, Lula will assume the base pose
to be at the origin with identity rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_position</strong> (<em>np.array</em>) – (3 x 1) translation vector describing the translation of the robot base relative to the USD stage origin.
The translation vector should be specified in the units of the USD stage</p></li>
<li><p><strong>robot_orientation</strong> (<em>np.array</em>) – (4 x 1) quaternion describing the orientation of the robot base relative to the USD stage global frame</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.set_cspace_target">
<span class="sig-name descname"><span class="pre">set_cspace_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active_joint_targets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.set_cspace_target" title="Permalink to this definition"></a></dt>
<dd><p>Set configuration space target for the robot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>active_joint_target</strong> (<em>np.array</em>) – Desired configuration for the robot as (m x 1) vector where m is the number of active
joints.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.set_end_effector_target">
<span class="sig-name descname"><span class="pre">set_end_effector_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_translation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.set_end_effector_target" title="Permalink to this definition"></a></dt>
<dd><p>Set end effector target.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_translation</strong> (<em>nd.array</em>) – Translation vector (3x1) for robot end effector.
Target translation should be specified in the same units as the USD stage, relative to the stage origin.</p></li>
<li><p><strong>target_orientation</strong> (<em>nd.array</em>) – Quaternion of desired rotation for robot end effector relative to USD stage global frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.get_active_joints">
<span class="sig-name descname"><span class="pre">get_active_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.get_active_joints" title="Permalink to this definition"></a></dt>
<dd><p>Active joints are directly controlled by this PathPlanner</p>
<p>Some articulated robot joints may be ignored by some policies. E.g., the gripper of the Franka arm is not used
to follow targets, and the RMPflow config files excludes the joints in the gripper from the list of articulated
joints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>names of active joints.  The order of joints in this list determines the order in which a
PathPlanner expects joint states to be specified in functions like compute_path(active_joint_positions,…)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.get_watched_joints">
<span class="sig-name descname"><span class="pre">get_watched_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.get_watched_joints" title="Permalink to this definition"></a></dt>
<dd><p>Lula does not currently support watching joint states that are not controllable</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Always returns an empty list.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(List)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.add_obstacle">
<span class="sig-name descname"><span class="pre">add_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.add_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Add an obstacle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obstacle</strong> (<em>omni.isaac.core.objects</em>) – An obstacle from the package omni.isaac.core.obstacles
The type of the obstacle will be checked, and the appropriate add function will be called</p></li>
<li><p><strong>static</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – When True, the obstacle will be assumed to remain stationary relative to the USD global frame over time</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns True if the obstacle type is valid and the appropriate add function has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>success (bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.add_cuboid">
<span class="sig-name descname"><span class="pre">add_cuboid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cuboid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicCuboid" title="omni.isaac.core.objects.cuboid.DynamicCuboid"><span class="pre">omni.isaac.core.objects.cuboid.DynamicCuboid</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.FixedCuboid" title="omni.isaac.core.objects.cuboid.FixedCuboid"><span class="pre">omni.isaac.core.objects.cuboid.FixedCuboid</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCuboid" title="omni.isaac.core.objects.cuboid.VisualCuboid"><span class="pre">omni.isaac.core.objects.cuboid.VisualCuboid</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.add_cuboid" title="Permalink to this definition"></a></dt>
<dd><p>Add a block obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cuboid</strong> (<em>core.objects.cuboid</em>) – Wrapper object for handling rectangular prism Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that cuboid will never change pose, and may be ignored in internal
world updates. Since Lula specifies object positions relative to the robot’s frame
of reference, static obstacles will have their positions queried any time that
set_robot_base_pose() is called.  Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Always True, indicating that this adder has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.add_sphere">
<span class="sig-name descname"><span class="pre">add_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sphere</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicSphere" title="omni.isaac.core.objects.sphere.DynamicSphere"><span class="pre">omni.isaac.core.objects.sphere.DynamicSphere</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualSphere" title="omni.isaac.core.objects.sphere.VisualSphere"><span class="pre">omni.isaac.core.objects.sphere.VisualSphere</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.add_sphere" title="Permalink to this definition"></a></dt>
<dd><p>Add a sphere obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sphere</strong> (<em>core.objects.sphere</em>) – Wrapper object for handling sphere Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that sphere will never change pose, and may be ignored in internal
world updates. Since Lula specifies object positions relative to the robot’s frame
of reference, static obstacles will have their positions queried any time that
set_robot_base_pose() is called.  Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Always True, indicating that this adder has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.add_capsule">
<span class="sig-name descname"><span class="pre">add_capsule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">capsule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.DynamicCapsule" title="omni.isaac.core.objects.capsule.DynamicCapsule"><span class="pre">omni.isaac.core.objects.capsule.DynamicCapsule</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.VisualCapsule" title="omni.isaac.core.objects.capsule.VisualCapsule"><span class="pre">omni.isaac.core.objects.capsule.VisualCapsule</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.add_capsule" title="Permalink to this definition"></a></dt>
<dd><p>Add a capsule obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>capsule</strong> (<em>core.objects.capsule</em>) – Wrapper object for handling capsule Usd Prims.</p></li>
<li><p><strong>static</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, indicate that capsule will never change pose, and may be ignored in internal
world updates. Since Lula specifies object positions relative to the robot’s frame
of reference, static obstacles will have their positions queried any time that
set_robot_base_pose() is called.  Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Always True, indicating that this function has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.add_ground_plane">
<span class="sig-name descname"><span class="pre">add_ground_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_plane</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.GroundPlane" title="omni.isaac.core.objects.ground_plane.GroundPlane"><span class="pre">omni.isaac.core.objects.ground_plane.GroundPlane</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.add_ground_plane" title="Permalink to this definition"></a></dt>
<dd><p>Add a ground_plane.
Lula does not support ground planes directly, and instead internally creates a cuboid with an
expansive face (dimensions 200x200 stage units) coplanar to the ground_plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ground_plane</strong> (<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.objects.GroundPlane" title="omni.isaac.core.objects.ground_plane.GroundPlane"><em>core.objects.ground_plane.GroundPlane</em></a>) – Wrapper object for handling ground_plane Usd Prims.</p></li>
<li><p><strong>plane_width</strong> (<em>Optional</em><em>[</em><em>float</em><em>]</em>) – The width of the ground plane (in meters) that Lula creates to constrain this robot.  Defaults to 50.0 m</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Always True, indicating that this adder has been implemented</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.disable_obstacle">
<span class="sig-name descname"><span class="pre">disable_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.disable_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Disable collision avoidance for obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.objects</em>) – obstacle to be disabled.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully disabled.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.enable_obstacle">
<span class="sig-name descname"><span class="pre">enable_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.enable_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Enable collision avoidance for obstacle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.objects</em>) – obstacle to be enabled.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully enabled.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.remove_obstacle">
<span class="sig-name descname"><span class="pre">remove_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.remove_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Remove obstacle from collision avoidance. Obstacle cannot be re-enabled via enable_obstacle() after
removal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>core.objects</em>) – obstacle to be removed.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Return True if obstacle was identified and successfully removed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.update_world">
<span class="sig-name descname"><span class="pre">update_world</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updated_obstacles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.update_world" title="Permalink to this definition"></a></dt>
<dd><p>Update the internal world state of Lula.
This function automatically tracks the positions of obstacles that have been added with add_obstacle()</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>updated_obstacles</strong> (<em>List</em><em>[</em><em>core.objects</em><em>]</em><em>, </em><em>optional</em>) – Obstacles that have been added by add_obstacle() that need to be updated.
If not specified, all non-static obstacle positions will be updated.
If specified, only the obstacles that have been listed will have their positions updated</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.reset" title="Permalink to this definition"></a></dt>
<dd><p>reset the world to its initial state</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.set_max_iterations">
<span class="sig-name descname"><span class="pre">set_max_iterations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.set_max_iterations" title="Permalink to this definition"></a></dt>
<dd><p>Set the maximum number of iterations of RRT before a failure is returned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_iter</strong> (<em>int</em>) – Maximum number of iterations of RRT before a failure is returned.
The time it takes to return a failure scales quadratically with max_iter</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.set_random_seed">
<span class="sig-name descname"><span class="pre">set_random_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.set_random_seed" title="Permalink to this definition"></a></dt>
<dd><p>Set the random seed that RRT uses to generate a solution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>random_seed</strong> (<em>int</em>) – Used to initialize random sampling. random_seed must be positive.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.RRT.set_param">
<span class="sig-name descname"><span class="pre">set_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.RRT.set_param" title="Permalink to this definition"></a></dt>
<dd><p>Set a parameter for the RRT algorithm.  The parameters and their appropriate values are enumerated below:</p>
<dl>
<dt><cite>seed</cite> (int):</dt><dd><p>-Used to initialize random sampling.
-<cite>seed</cite> must be positive.
-This parameter may also be set through the set_random_seed() function</p>
</dd>
<dt><cite>step_size</cite> (float):</dt><dd><p>-Step size for tree extension.
-It is assumed that a straight path connecting two valid c-space configurations with
separation distance &lt;= <cite>step_size</cite> is a valid edge, where separation distance is defined
as the L2-norm of the difference between the two configurations.
-<cite>step_size</cite> must be positive.</p>
</dd>
<dt><cite>max_iterations</cite> (int)</dt><dd><ul class="simple">
<li><p>Maximum number of iterations of tree extensions that will be attempted.</p></li>
<li><p>If <cite>max_iterations</cite> is reached without finding a valid path, the <cite>Results</cite> will
indicate <cite>path_found</cite> is <cite>false</cite> and <cite>path</cite> will be an empty vector.</p></li>
<li><p><cite>max_iterations</cite> must be positive.</p></li>
</ul>
</dd>
<dt><cite>distance_metric_weights</cite> (np.array[np.float64[num_dof,]])</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>When selecting a node for tree extension, the closest node is defined using a weighted, squared L2-norm:</dt><dd><p>distance = (q0 - q1)^T * W * (q0 - q1)
where q0 and q1 represent two configurations and W is a diagonal matrix formed from
<cite>distance_metric_weights</cite>.</p>
</dd>
</dl>
</li>
<li><p>The length of the <cite>distance_metric_weights</cite> must be equal to the number of c-space
coordinates for the robot and each weight must be positive.</p></li>
</ul>
</dd>
<dt><cite>task_space_frame_name</cite> (string)</dt><dd><ul class="simple">
<li><p>Indicate the name (from URDF) of the frame to be used for task space planning.</p></li>
<li><p>With current implementation, setting a <cite>task_space_frame_name</cite> that is not found in the
kinematics will throw an exception rather than failing gracefully.</p></li>
</ul>
</dd>
<dt><cite>task_space_limits</cite> (np.array[np.float64[3,2]])</dt><dd><ul class="simple">
<li><p>Task space limits define a bounding box used for sampling task space when planning
a path to a task space target.</p></li>
<li><p>The specified <cite>task_space_limits</cite> should be a (3 x 2) matrix.  Rows correspond to the xyz
dimensions of the bounding box, and columns 0 and 1 correspond to the lower and upper limit repectively.</p></li>
<li><p>Each upper limit must be &gt;= the corresponding lower limit.</p></li>
</ul>
</dd>
<dt><cite>c_space_planning_params/exploration_fraction</cite> (float)</dt><dd><ul class="simple">
<li><p>The c-space planner uses RRT-Connect to try to find a path to a c-space target.</p></li>
<li><dl class="simple">
<dt>RRT-Connect attempts to iteratively extend two trees (one from the initial configuration and one from the target configuration)</dt><dd><p>until the two trees can be connected. The
configuration to which a tree is extended can be either a random sample
(i.e., exploration) or a node on the tree to which connection is desired
(i.e., exploitation). The <cite>exploration_fraction</cite> controls the fraction of steps that are
exploration steps. It is generally recommended to set <cite>exploration_fraction</cite> in range
[0.5, 1), where 1 corresponds to a single initial exploitation step followed by only
exploration steps. Values of between [0, 0.5) correspond to more exploitation than
exploration and are not recommended. If a value outside range [0, 1] is provided, a
warning is logged and the value is clamped to range [0, 1].</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A default value of 0.5 is recommended as a starting value for initial testing with a given</dt><dd><p>system.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><cite>task_space_planning_params/x_target_zone_tolerance</cite> (np.array[np.float64[3,]])</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>A configuration has reached the task space target when task space position, x(i), is in</dt><dd><p>the range x_target(i) +/- x_target_zone_tolerance(i).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>It is assumed that a valid configuration within the target tolerance can be moved directly</dt><dd><p>to the target configuration using Jacobian transpose control.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>In general, it is recommended that the target zone bounding box have dimensions close to</dt><dd><p>the <cite>step_size</cite>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><cite>task_space_planning_params/x_target_final_tolerance</cite> (float)</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>Once a path is found that terminates within <cite>x_target_zone_tolerance</cite>, a numeric solver is</dt><dd><p>used to find a configuration space solution corresponding to the task space target. This
solver terminates when the L2-norm of the corresponding task space position is within
<cite>x_target_final_tolerance</cite> of the target.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Note: This solver assumes that if a c-space configuration within <cite>x_target_zone_tolerance</cite></dt><dd><p>is found then this c-space configuration can be extended towards the task space target
using the Jacobian transpose method. If this assumption is NOT met, the returned path will
not reach the task space target within the <cite>x_target_final_tolerance</cite> and an error is
logged.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The recommended default value is 1e-5, but in general this value should be set to a</dt><dd><p>positive value that is considered “good enough” precision for the specific system.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><cite>task_space_planning_params/task_space_exploitation_fraction</cite> (float)</dt><dd><ul class="simple">
<li><p>Fraction of iterations for which tree is extended towards target position in task space.</p></li>
<li><dl class="simple">
<dt>Must be in range [0, 1]. Additionally, the sum of <cite>task_space_exploitation_fraction</cite> and</dt><dd><p><cite>task_space_exploration_fraction</cite> must be &lt;= 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A default value of 0.4 is recommended as a starting value for initial testing with a given</dt><dd><p>system.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><cite>task_space_planning_params/task_space_exploration_fraction</cite> (float)</dt><dd><ul class="simple">
<li><p>Fraction of iterations for which tree is extended towards random position in task space.</p></li>
<li><dl class="simple">
<dt>Must be in range [0, 1]. Additionally, the sum of <cite>task_space_exploitation_fraction</cite> and</dt><dd><p><cite>task_space_exploration_fraction</cite> must be &lt;= 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>A default value of 0.1 is recommended as a starting value for initial testing with a given</dt><dd><p>system.</p>
</dd>
</dl>
</li>
</ul>
<p>The remaining fraction beyond <cite>task_space_exploitation_fraction</cite> and
<cite>task_space_exploration_fraction</cite> is a <cite>c_space_exploration_fraction</cite> that is
implicitly defined as:</p>
<p>1 - (<cite>task_space_exploitation_fraction</cite> + <cite>task_space_exploration_fraction</cite>)</p>
<p>In general, easier path searches will take less time with higher exploitation fraction
while more difficult searches will waste time if the exploitation fraction is too high
and benefit from greater combined exploration fraction.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_name</strong> (<em>str</em>) – Name of parameter</p></li>
<li><p><strong>value</strong> (<em>Union</em><em>[</em><em>np.ndarray</em><em>[</em><em>np.float64</em><em>]</em><em>,</em><em>float</em><em>,</em><em>int</em><em>,</em><em>str</em><em>]</em>) – value of parameter</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the parameter was set successfully</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="trajectory">
<h2>Trajectory<a class="headerlink" href="#trajectory" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.Trajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Trajectory</span></span><a class="headerlink" href="#omni.isaac.motion_generation.Trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Interface class for defining a continuous-time trajectory for a robot in Isaac Sim.
A Trajectory may be passed to an ArticulationTrajectory to have its continuous-time output discretized and converted
to a ArticulationActions.</p>
<dl class="py property">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.Trajectory.start_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">start_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#omni.isaac.motion_generation.Trajectory.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Return the start time of the trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Start time of the trajectory.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.Trajectory.end_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">end_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#omni.isaac.motion_generation.Trajectory.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Return the end time of the trajectory</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>End time of the trajectory</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.Trajectory.get_active_joints">
<span class="sig-name descname"><span class="pre">get_active_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.Trajectory.get_active_joints" title="Permalink to this definition"></a></dt>
<dd><p>Active joints are directly controlled by this Trajectory</p>
<p>A Trajectory may be specified for only a subset of the joints in a robot Articulation.  For example, it may include the DOFs in a robot
arm, but not in the gripper.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>Names of active joints.  The order of joints in this list determines the order in which a</dt><dd><p>Trajectory will return joint targets for the robot.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.Trajectory.get_joint_targets">
<span class="sig-name descname"><span class="pre">get_joint_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.Trajectory.get_joint_targets" title="Permalink to this definition"></a></dt>
<dd><p>Return joint targets for the robot at the given time.  The Trajectory interface assumes trajectories to
be represented continuously between a start time and end time.  In instance of this class that internally generates discrete time
trajectories will need to implement some form of interpolation for times that have not been computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> (<em>float</em>) – Time in trajectory at which to return joint targets.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>joint position targets for the active robot joints</p>
<p>joint velocity targets for the active robot joints</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LulaTrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_joints</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Instance of Trajectory interface class for handling lula.Trajectory objects</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>trajectory</strong> (<a class="reference internal" href="../../omni.isaac.lula/docs/index.html#lula.Trajectory" title="lula.Trajectory"><em>lula.Trajectory</em></a>) – C-space trajectory defined continuously</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTrajectory.start_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">start_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTrajectory.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Return the start time of the trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Start time of the trajectory.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTrajectory.end_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">end_time</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTrajectory.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Return the end time of the trajectory</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>End time of the trajectory</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTrajectory.get_active_joints">
<span class="sig-name descname"><span class="pre">get_active_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTrajectory.get_active_joints" title="Permalink to this definition"></a></dt>
<dd><p>Active joints are directly controlled by this Trajectory</p>
<p>A Trajectory may be specified for only a subset of the joints in a robot Articulation.  For example, it may include the DOFs in a robot
arm, but not in the gripper.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>Names of active joints.  The order of joints in this list determines the order in which a</dt><dd><p>Trajectory will return joint targets for the robot.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTrajectory.get_joint_targets">
<span class="sig-name descname"><span class="pre">get_joint_targets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.array</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.array</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTrajectory.get_joint_targets" title="Permalink to this definition"></a></dt>
<dd><p>Return joint targets for the robot at the given time.  The Trajectory interface assumes trajectories to
be represented continuously between a start time and end time.  In instance of this class that internally generates discrete time
trajectories will need to implement some form of interpolation for times that have not been computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> (<em>float</em>) – Time in trajectory at which to return joint targets.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>joint position targets for the active robot joints</p>
<p>joint velocity targets for the active robot joints</p>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[np.array,np.array]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="lula-trajectory-generators">
<h2>Lula Trajectory Generators<a class="headerlink" href="#lula-trajectory-generators" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LulaCSpaceTrajectoryGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_description_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">urdf_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator" title="Permalink to this definition"></a></dt>
<dd><p>LulaCSpaceTrajectoryGenerator is a class for generating time-optimal trajectories that connect a series of
provided c-space waypoints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_description_path</strong> (<em>str</em>) – path to a robot description yaml file</p></li>
<li><p><strong>urdf_path</strong> (<em>str</em>) – path to robot urdf</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.compute_c_space_trajectory">
<span class="sig-name descname"><span class="pre">compute_c_space_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">waypoint_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.lula.LulaTrajectory" title="omni.isaac.motion_generation.lula.trajectory_generator.LulaTrajectory"><span class="pre">omni.isaac.motion_generation.lula.trajectory_generator.LulaTrajectory</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.compute_c_space_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Produce a trajectory from a set of provided c_space waypoint positions.  The resulting trajectory
will use spline-based interpolation to connect the waypoints with an initial and final velocity of 0.  The trajectory is time-optimal:
i.e. either the velocity, acceleration, or jerk limits are saturated at any given time to produce as trajectory with as short a duration as possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>waypoint_positions</strong> (<em>np.array</em>) – Set of c-space coordinates cooresponding to the output of get_active_joints().
The expected shape is (N x k) where N is the number of waypoints and k is the number of active joints.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Instance of the Trajectory class which specifies continuous joint_targets for the active joints over a span of time.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#omni.isaac.motion_generation.lula.LulaTrajectory" title="omni.isaac.motion_generation.lula.LulaTrajectory">LulaTrajectory</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.get_active_joints">
<span class="sig-name descname"><span class="pre">get_active_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.get_active_joints" title="Permalink to this definition"></a></dt>
<dd><p>Return the list of joints by name that are considered to be controllable by the TrajectoryGenerator.
All inputs and outputs of the LulaTrajectoryGenerator correspond to the joints specified by get_active_joints().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List of joints that are used to generate the desired trajectory.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_c_space_position_limits">
<span class="sig-name descname"><span class="pre">set_c_space_position_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower_position_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_position_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_c_space_position_limits" title="Permalink to this definition"></a></dt>
<dd><p>Set the lower and upper position limits of the active joints to be used when generating a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower_position_limits</strong> (<em>np.array</em>) – Lower position limits of active joints.</p></li>
<li><p><strong>upper_position_limits</strong> (<em>np.array</em>) – Upper position limits of active joints.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_c_space_velocity_limits">
<span class="sig-name descname"><span class="pre">set_c_space_velocity_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">velocity_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_c_space_velocity_limits" title="Permalink to this definition"></a></dt>
<dd><p>Set the velocity limits of the active joints to be used when generating a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>velocity_limits</strong> (<em>np.array</em>) – Velocity limits of active joints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_c_space_acceleration_limits">
<span class="sig-name descname"><span class="pre">set_c_space_acceleration_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">acceleration_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_c_space_acceleration_limits" title="Permalink to this definition"></a></dt>
<dd><p>Set the acceleration limits of the active joints to be used when generating a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>acceleration_limits</strong> (<em>np.array</em>) – Acceleration limits of active joints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_c_space_jerk_limits">
<span class="sig-name descname"><span class="pre">set_c_space_jerk_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">jerk_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_c_space_jerk_limits" title="Permalink to this definition"></a></dt>
<dd><p>Set the jerk limits of the active joints to be used when generating a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>jerk_limits</strong> (<em>np.array</em>) – Jerk limits of active joints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_solver_param">
<span class="sig-name descname"><span class="pre">set_solver_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_val</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaCSpaceTrajectoryGenerator.set_solver_param" title="Permalink to this definition"></a></dt>
<dd><p>Set solver parameters for the cspace trajectory generator.  A complete list of
parameters is provided in this docstring.</p>
<dl>
<dt>‘max_segment_iterations’: (int)</dt><dd><p>In general, a trajectory is locally time-optimal if at least one derivative for one of the
c-space coordinates is fully saturated, with no derivative limits for any of the c-space
coordinates exceeded.</p>
<p>This time-optimality can be enforced for each <cite>CubicSpline</cite> segment or for each
<cite>PiecewiseCubicSpline</cite> as a whole. The former will, in general, generate trajectories with
smaller spans, but will require more expensive iterations (and thus more time) to converge.
The latter will, in general, require less iterations (and thus less time) to converge, but
the generated trajectories will tend to have longer spans.</p>
<p>When attempting to find a time-optimal trajectory, the (more expensive) per-segment method
will first be attempted for <cite>max_per_segment_iterations</cite>. Then, if not yet converged, the
method acting on the entire spline will be attempted for <cite>max_aggregate_iterations</cite>.</p>
<p>To maximize speed, <cite>max_segment_iterations</cite> should be relatively low (or even zero to remove
this search completely). To maximize time-optimality of the generated trajectory,
<cite>max_segment_iterations</cite> should be relatively high.</p>
<p>The sum of <cite>max_segment_iterations</cite> and <cite>max_aggregate_iterations</cite> must be at least 1</p>
</dd>
<dt>‘max_aggragate_iterations’: (int)</dt><dd><p>See max_segment_iterations</p>
</dd>
<dt>‘convergence_dt’: (float)</dt><dd><p>The search for optimal time values will terminate if the maximum change to any time value
during a given iteration is less than the <cite>convergence_dt</cite>.</p>
<p><cite>convergence_dt</cite> must be positive.</p>
</dd>
<dt>‘max_dilation_iterations’: (int)</dt><dd><p>After the segment-wise and/or aggregate time-optimal search has converged or reached maximum
iterations, the resulting set of splines will be tested to see if any derivative limits are
exceeded.</p>
<p>If any derivative limits are exceeded, the splines will be iteratively scaled in time to
reduce the maximum achieved derivative. This process will repeat until no derivative limits
are exceeded (success) or <cite>max_dilation_iterations_</cite> are reached (failure).
For a well-tuned set of solver parameters, very few dilation steps should be required
(often none will be required or a single iteration is sufficient to bring a slightly
over-saturated trajectory within the derivative limits).</p>
</dd>
<dt>‘dilation_dt’: (float)</dt><dd><p>For the iterative dilation step described in <cite>setMaxDilationIterations()</cite> documentation, the
<cite>dilation_dt</cite> is the “epsilon” value added to the span of the trajectory that exceeds
derivative limits.</p>
<p><cite>dilation_dt</cite> must be positive.</p>
</dd>
<dt>‘min_time_span’: (float)</dt><dd><p>Specify the minimum allowable time span between adjacent waypoints/endpoints.
<cite>min_time_span</cite> must be positive.</p>
<p>This is most likely to affect the time span between the endpoints and “free-position” points
that are used to enable acceleration bound constraints. If no jerk limit is provided, these free-position points may
tend to become arbitrarily close in position and time to the endpoints. This <cite>min_time_span</cite>
prevents this time span from approaching zero.</p>
<p>In general, a jerk limit is recommended for preventing abrupt changes in acceleration rather
than relying on the <cite>min_time_span</cite> for this purpose.</p>
</dd>
<dt>‘time_split_method’: (string)</dt><dd><p>Often waypoints for a trajectory may specify positions without providing time values for when
these waypoint position should be attained. In this case, we can use the distance between
waypoints to assign time values for each waypoint.</p>
<p>Assuming a unitary time domain s.t. t_0 = 0 and t_N = 1, we can assign the intermediate time
values according to:</p>
<blockquote>
<div><p>t_k = t_(k-1) + (d_k / d),</p>
</div></blockquote>
<p>where d = sum(d_k) for k = [0, N-1] and N is the number of points.</p>
<p>Many options exist for the computing the distance metric d_k, with common options described
below (and implemented in <cite>ComputeTimeValues()</cite>.
See Eqn 4.37 in “Trajectory Planning for Automatic Machines and Robots” (2008) by
Biagiotti &amp; Melchiorri for more detailed motivations.
Valid distribution choices are given below:</p>
<dl>
<dt>‘uniform’:</dt><dd><p>For a “uniform distribution” w.r.t time, the positions are ignored and d_k can simply be
computed as:</p>
<blockquote>
<div><p>d_k = 1 / (N - 1)</p>
</div></blockquote>
<p>resulting in uniform time intervals between all points.</p>
</dd>
<dt>‘chord_length’:</dt><dd><p>For a “chord length distribution”, the time intervals between waypoints are proportional to
the Euclidean distance between waypoints:</p>
<blockquote>
<div><p>d_k = |q_(k+1) - q_k|</p>
</div></blockquote>
<p>where q represents the position of the waypoint.</p>
</dd>
<dt>‘centripetal’:</dt><dd><p>For a “centripetal distribution”, the time intervals between waypoints are proportional to the
square root of the Euclidean distance between waypoints:</p>
<blockquote>
<div><p>d_k = |q_(k+1) - q_k|^(1/2)</p>
</div></blockquote>
<p>where q represents the position of the waypoint.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_name</strong> (<em>str</em>) – Parameter name from the above list of parameters</p></li>
<li><p><strong>param_val</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>float</em><em>, </em><em>str</em><em>]</em>) – Value to which the given parameter will be set</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LulaTaskSpaceTrajectoryGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_description_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">urdf_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.get_active_joints">
<span class="sig-name descname"><span class="pre">get_active_joints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.get_active_joints" title="Permalink to this definition"></a></dt>
<dd><p>Return the list of joints by name that are considered to be controllable by the TrajectoryGenerator.
All inputs and outputs of the LulaTrajectoryGenerator correspond to the joints specified by get_active_joints().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List of joints that are used to generate the desired trajectory.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_position_limits">
<span class="sig-name descname"><span class="pre">set_c_space_position_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower_position_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_position_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_position_limits" title="Permalink to this definition"></a></dt>
<dd><p>Set the lower and upper position limits of the active joints to be used when generating a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower_position_limits</strong> (<em>np.array</em>) – Lower position limits of active joints.</p></li>
<li><p><strong>upper_position_limits</strong> (<em>np.array</em>) – Upper position limits of active joints.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_velocity_limits">
<span class="sig-name descname"><span class="pre">set_c_space_velocity_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">velocity_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_velocity_limits" title="Permalink to this definition"></a></dt>
<dd><p>Set the velocity limits of the active joints to be used when generating a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>velocity_limits</strong> (<em>np.array</em>) – Velocity limits of active joints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_acceleration_limits">
<span class="sig-name descname"><span class="pre">set_c_space_acceleration_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">acceleration_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_acceleration_limits" title="Permalink to this definition"></a></dt>
<dd><p>Set the acceleration limits of the active joints to be used when generating a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>acceleration_limits</strong> (<em>np.array</em>) – Acceleration limits of active joints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_jerk_limits">
<span class="sig-name descname"><span class="pre">set_c_space_jerk_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">jerk_limits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_jerk_limits" title="Permalink to this definition"></a></dt>
<dd><p>Set the jerk limits of the active joints to be used when generating a trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>jerk_limits</strong> (<em>np.array</em>) – Jerk limits of active joints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_trajectory_generator_solver_param">
<span class="sig-name descname"><span class="pre">set_c_space_trajectory_generator_solver_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_val</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.set_c_space_trajectory_generator_solver_param" title="Permalink to this definition"></a></dt>
<dd><p>Set solver parameters for the cspace trajectory generator.  A complete list of
parameters is provided in this docstring.</p>
<dl>
<dt>‘max_segment_iterations’: (int)</dt><dd><p>In general, a trajectory is locally time-optimal if at least one derivative for one of the
c-space coordinates is fully saturated, with no derivative limits for any of the c-space
coordinates exceeded.</p>
<p>This time-optimality can be enforced for each <cite>CubicSpline</cite> segment or for each
<cite>PiecewiseCubicSpline</cite> as a whole. The former will, in general, generate trajectories with
smaller spans, but will require more expensive iterations (and thus more time) to converge.
The latter will, in general, require less iterations (and thus less time) to converge, but
the generated trajectories will tend to have longer spans.</p>
<p>When attempting to find a time-optimal trajectory, the (more expensive) per-segment method
will first be attempted for <cite>max_per_segment_iterations</cite>. Then, if not yet converged, the
method acting on the entire spline will be attempted for <cite>max_aggregate_iterations</cite>.</p>
<p>To maximize speed, <cite>max_segment_iterations</cite> should be relatively low (or even zero to remove
this search completely). To maximize time-optimality of the generated trajectory,
<cite>max_segment_iterations</cite> should be relatively high.</p>
<p>The sum of <cite>max_segment_iterations</cite> and <cite>max_aggregate_iterations</cite> must be at least 1</p>
</dd>
<dt>‘max_aggragate_iterations’: (int)</dt><dd><p>See max_segment_iterations</p>
</dd>
<dt>‘convergence_dt’: (float)</dt><dd><p>The search for optimal time values will terminate if the maximum change to any time value
during a given iteration is less than the <cite>convergence_dt</cite>.</p>
<p><cite>convergence_dt</cite> must be positive.</p>
</dd>
<dt>‘max_dilation_iterations’: (int)</dt><dd><p>After the segment-wise and/or aggregate time-optimal search has converged or reached maximum
iterations, the resulting set of splines will be tested to see if any derivative limits are
exceeded.</p>
<p>If any derivative limits are exceeded, the splines will be iteratively scaled in time to
reduce the maximum achieved derivative. This process will repeat until no derivative limits
are exceeded (success) or <cite>max_dilation_iterations_</cite> are reached (failure).
For a well-tuned set of solver parameters, very few dilation steps should be required
(often none will be required or a single iteration is sufficient to bring a slightly
over-saturated trajectory within the derivative limits).</p>
</dd>
<dt>‘dilation_dt’: (float)</dt><dd><p>For the iterative dilation step described in <cite>setMaxDilationIterations()</cite> documentation, the
<cite>dilation_dt</cite> is the “epsilon” value added to the span of the trajectory that exceeds
derivative limits.</p>
<p><cite>dilation_dt</cite> must be positive.</p>
</dd>
<dt>‘min_time_span’: (float)</dt><dd><p>Specify the minimum allowable time span between adjacent waypoints/endpoints.
<cite>min_time_span</cite> must be positive.</p>
<p>This is most likely to affect the time span between the endpoints and “free-position” points
that are used to enable acceleration bound constraints. If no jerk limit is provided, these free-position points may
tend to become arbitrarily close in position and time to the endpoints. This <cite>min_time_span</cite>
prevents this time span from approaching zero.</p>
<p>In general, a jerk limit is recommended for preventing abrupt changes in acceleration rather
than relying on the <cite>min_time_span</cite> for this purpose.</p>
</dd>
<dt>‘time_split_method’: (string)</dt><dd><p>Often waypoints for a trajectory may specify positions without providing time values for when
these waypoint position should be attained. In this case, we can use the distance between
waypoints to assign time values for each waypoint.</p>
<p>Assuming a unitary time domain s.t. t_0 = 0 and t_N = 1, we can assign the intermediate time
values according to:</p>
<blockquote>
<div><p>t_k = t_(k-1) + (d_k / d),</p>
</div></blockquote>
<p>where d = sum(d_k) for k = [0, N-1] and N is the number of points.</p>
<p>Many options exist for the computing the distance metric d_k, with common options described
below (and implemented in <cite>ComputeTimeValues()</cite>.
See Eqn 4.37 in “Trajectory Planning for Automatic Machines and Robots” (2008) by
Biagiotti &amp; Melchiorri for more detailed motivations.
Valid distribution choices are given below:</p>
<dl>
<dt>‘uniform’:</dt><dd><p>For a “uniform distribution” w.r.t time, the positions are ignored and d_k can simply be
computed as:</p>
<blockquote>
<div><p>d_k = 1 / (N - 1)</p>
</div></blockquote>
<p>resulting in uniform time intervals between all points.</p>
</dd>
<dt>‘chord_length’:</dt><dd><p>For a “chord length distribution”, the time intervals between waypoints are proportional to
the Euclidean distance between waypoints:</p>
<blockquote>
<div><p>d_k = |q_(k+1) - q_k|</p>
</div></blockquote>
<p>where q represents the position of the waypoint.</p>
</dd>
<dt>‘centripetal’:</dt><dd><p>For a “centripetal distribution”, the time intervals between waypoints are proportional to the
square root of the Euclidean distance between waypoints:</p>
<blockquote>
<div><p>d_k = |q_(k+1) - q_k|^(1/2)</p>
</div></blockquote>
<p>where q represents the position of the waypoint.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param_name</strong> (<em>str</em>) – Parameter name from the above list of parameters</p></li>
<li><p><strong>param_val</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>float</em><em>, </em><em>str</em><em>]</em>) – Value to which the given parameter will be set</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.get_all_frame_names">
<span class="sig-name descname"><span class="pre">get_all_frame_names</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.get_all_frame_names" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of all frames in the robot URDF that may be used to follow a trajectory</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List of all frame names in the robot URDF</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.compute_task_space_trajectory_from_points">
<span class="sig-name descname"><span class="pre">compute_task_space_trajectory_from_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.lula.LulaTrajectory" title="omni.isaac.motion_generation.lula.trajectory_generator.LulaTrajectory"><span class="pre">omni.isaac.motion_generation.lula.trajectory_generator.LulaTrajectory</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.compute_task_space_trajectory_from_points" title="Permalink to this definition"></a></dt>
<dd><p>Return a LulaTrajectory that connects the provided positions and orientations at the specified frame in the robot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positions</strong> (<em>np.array</em>) – Taskspace positions that the robot end effector should pass through with shape (N x 3) where N is the number of provided positions.
Positions is assumed to be in meters.</p></li>
<li><p><strong>orientations</strong> (<em>np.array</em>) – Taskspace quaternion orientations that the robot end effector should pass through with shape (N x 4) where N is the number of provided
orientations.  The length of this argument must match the length of the positions argument.</p></li>
<li><p><strong>frame_name</strong> (<em>str</em>) – Name of the end effector frame in the robot URDF.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Instance of the omni.isaac.motion_generation.Trajectory class.  If no trajectory could be generated, None is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#omni.isaac.motion_generation.lula.LulaTrajectory" title="omni.isaac.motion_generation.lula.LulaTrajectory">LulaTrajectory</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.compute_task_space_trajectory_from_path_spec">
<span class="sig-name descname"><span class="pre">compute_task_space_trajectory_from_path_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">task_space_path_spec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../omni.isaac.lula/docs/index.html#lula.TaskSpacePathSpec" title="lula.TaskSpacePathSpec"><span class="pre">lula.TaskSpacePathSpec</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.lula.LulaTrajectory" title="omni.isaac.motion_generation.lula.trajectory_generator.LulaTrajectory"><span class="pre">omni.isaac.motion_generation.lula.trajectory_generator.LulaTrajectory</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.compute_task_space_trajectory_from_path_spec" title="Permalink to this definition"></a></dt>
<dd><p>Return a LulaTrajectory that follows the path specified by the provided TaskSpacePathSpec</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>task_space_path_spec</strong> (<a class="reference internal" href="../../omni.isaac.lula/docs/index.html#lula.TaskSpacePathSpec" title="lula.TaskSpacePathSpec"><em>lula.TaskSpacePathSpec</em></a>) – An object describing a taskspace path</p></li>
<li><p><strong>frame_name</strong> (<em>str</em>) – Name of the end effector frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Instance of the omni.isaac.motion_generation.Trajectory class.  If no trajectory could be generated, None is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#omni.isaac.motion_generation.lula.LulaTrajectory" title="omni.isaac.motion_generation.lula.LulaTrajectory">LulaTrajectory</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.get_path_conversion_config">
<span class="sig-name descname"><span class="pre">get_path_conversion_config</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.lula/docs/index.html#lula.TaskSpacePathConversionConfig" title="lula.TaskSpacePathConversionConfig"><span class="pre">lula.TaskSpacePathConversionConfig</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.lula.LulaTaskSpaceTrajectoryGenerator.get_path_conversion_config" title="Permalink to this definition"></a></dt>
<dd><p>Get a reference to the config object that lula uses to convert task-space paths to c-space paths.</p>
<p>The values of the returned TaskSpacePathConversionConfig object can be modified directly to affect lula task-space path conversions.
See help(lula.TaskSpacePathConversionConfig) for a detailed description of the editable parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Configuration class for converting from task-space paths to c-space paths.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="../../omni.isaac.lula/docs/index.html#lula.TaskSpacePathConversionConfig" title="lula.TaskSpacePathConversionConfig">lula.TaskSpacePathConversionConfig</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="articulationtrajectory">
<h2>ArticulationTrajectory<a class="headerlink" href="#articulationtrajectory" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ArticulationTrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">robot_articulation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.articulation.Articulation"><span class="pre">omni.isaac.core.articulations.articulation.Articulation</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#omni.isaac.motion_generation.Trajectory" title="omni.isaac.motion_generation.trajectory.Trajectory"><span class="pre">omni.isaac.motion_generation.trajectory.Trajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">physics_dt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper class which takes in a Trajectory object and converts the output to discrete ArticulationActions that may be sent to the provided robot Articulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>robot_articulation</strong> (<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.Articulation"><em>Articulation</em></a>) – Initialized robot Articulation object representing the simulated USD robot</p></li>
<li><p><strong>trajectory</strong> (<a class="reference internal" href="#omni.isaac.motion_generation.Trajectory" title="omni.isaac.motion_generation.Trajectory"><em>Trajectory</em></a>) – An instance of a class that implements the Trajectory interface.</p></li>
<li><p><strong>physics_dt</strong> (<em>float</em>) – Duration of a physics step in Isaac Sim (typically 1/60 s).</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationTrajectory.get_action_at_time">
<span class="sig-name descname"><span class="pre">get_action_at_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction"><span class="pre">omni.isaac.core.utils.types.ArticulationAction</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationTrajectory.get_action_at_time" title="Permalink to this definition"></a></dt>
<dd><p>Get an ArticulationAction that will send the robot to the desired position/velocity at a given time in the provided Trajectory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> (<em>float</em>) – Time between the start and end times in the provided Trajectory.  If the time is out of bounds, an error will be thrown.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ArticulationAction that may be passed directly to the robot Articulation to send it to the desired position/velocity at the given time.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction">ArticulationAction</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationTrajectory.get_action_sequence">
<span class="sig-name descname"><span class="pre">get_action_sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timestep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction"><span class="pre">omni.isaac.core.utils.types.ArticulationAction</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationTrajectory.get_action_sequence" title="Permalink to this definition"></a></dt>
<dd><p>Get a sequence of ArticulationActions which sample the entire Trajectory according to the provided timestep.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>timestep</strong> (<em>float</em><em>, </em><em>optional</em>) – Timestep used for sampling the provided Trajectory.
A vlue of 1/60, for example, returns ArticulationActions that represent the desired position/velocity of
the robot at 1/60 second intervals.  I.e. a one second trajectory with timestep=1/60 would result in 60 ArticulationActions.
When not provided, the framerate of Isaac Sim is used. Defaults to None.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sequence of ArticulationActions that may be passed to the robot Articulation to produce the desired trajectory.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction">ArticulationAction</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationTrajectory.get_trajectory_duration">
<span class="sig-name descname"><span class="pre">get_trajectory_duration</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationTrajectory.get_trajectory_duration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the duration of the provided Trajectory</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Duration of the provided trajectory</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationTrajectory.get_active_joints_subset">
<span class="sig-name descname"><span class="pre">get_active_joints_subset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.ArticulationSubset" title="omni.isaac.core.articulations.articulation_subset.ArticulationSubset"><span class="pre">omni.isaac.core.articulations.articulation_subset.ArticulationSubset</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationTrajectory.get_active_joints_subset" title="Permalink to this definition"></a></dt>
<dd><p>Get view into active joints</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns robot states for active joints in an order compatible with the TrajectoryGenerator</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.ArticulationSubset" title="omni.isaac.core.articulations.ArticulationSubset">ArticulationSubset</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationTrajectory.get_robot_articulation">
<span class="sig-name descname"><span class="pre">get_robot_articulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.articulation.Articulation"><span class="pre">omni.isaac.core.articulations.articulation.Articulation</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationTrajectory.get_robot_articulation" title="Permalink to this definition"></a></dt>
<dd><p>Get the robot Articulation</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Articulation object describing the robot.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.articulations.Articulation" title="omni.isaac.core.articulations.Articulation">Articulation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.ArticulationTrajectory.get_trajectory">
<span class="sig-name descname"><span class="pre">get_trajectory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.Trajectory" title="omni.isaac.motion_generation.trajectory.Trajectory"><span class="pre">omni.isaac.motion_generation.trajectory.Trajectory</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.ArticulationTrajectory.get_trajectory" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-omni.isaac.motion_generation.motion_policy_controller">
<span id="motion-policy-base-controller"></span><h2>Motion Policy Base Controller<a class="headerlink" href="#module-omni.isaac.motion_generation.motion_policy_controller" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MotionPolicyController</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">articulation_motion_policy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#omni.isaac.motion_generation.ArticulationMotionPolicy" title="omni.isaac.motion_generation.articulation_motion_policy.ArticulationMotionPolicy"><span class="pre">omni.isaac.motion_generation.articulation_motion_policy.ArticulationMotionPolicy</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController" title="Permalink to this definition"></a></dt>
<dd><p>A Controller that steps using an arbitrary MotionPolicy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – name of this controller</p></li>
<li><p><strong>articulation_motion_policy</strong> (<a class="reference internal" href="#omni.isaac.motion_generation.ArticulationMotionPolicy" title="omni.isaac.motion_generation.ArticulationMotionPolicy"><em>ArticulationMotionPolicy</em></a>) – a wrapper around a MotionPolicy for computing ArticulationActions that can be directly applied to the robot</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.add_obstacle">
<span class="sig-name descname"><span class="pre">add_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.add_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Add an object from omni.isaac.core.objects as an obstacle to the motion_policy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obstacle</strong> (<em>omni.isaac.core.objects</em>) – Dynamic, Visual, or Fixed object from omni.isaac.core.objects</p></li>
<li><p><strong>static</strong> (<em>bool</em>) – If True, the obstacle may be assumed by the MotionPolicy to remain stationary over time</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_end_effector_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_end_effector_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction"><span class="pre">omni.isaac.core.utils.types.ArticulationAction</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.forward" title="Permalink to this definition"></a></dt>
<dd><p>Compute an ArticulationAction representing the desired robot state for the next simulation frame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_translation</strong> (<em>nd.array</em>) – Translation vector (3x1) for robot end effector.
Target translation should be specified in the same units as the USD stage, relative to the stage origin.</p></li>
<li><p><strong>target_orientation</strong> (<em>Optional</em><em>[</em><em>np.ndarray</em><em>]</em><em>, </em><em>optional</em>) – Quaternion of desired rotation for robot end effector relative to USD stage global frame.
Target orientation defaults to None, which means that the robot may reach the target with any orientation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A wrapper object containing the desired next state for the robot</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction">ArticulationAction</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.get_articulation_motion_policy">
<span class="sig-name descname"><span class="pre">get_articulation_motion_policy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.ArticulationMotionPolicy" title="omni.isaac.motion_generation.articulation_motion_policy.ArticulationMotionPolicy"><span class="pre">omni.isaac.motion_generation.articulation_motion_policy.ArticulationMotionPolicy</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.get_articulation_motion_policy" title="Permalink to this definition"></a></dt>
<dd><p>Get ArticulationMotionPolicy that was passed to this class on initialization</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a wrapper around a MotionPolicy for computing ArticulationActions that can be directly applied to the robot</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#omni.isaac.motion_generation.ArticulationMotionPolicy" title="omni.isaac.motion_generation.ArticulationMotionPolicy">ArticulationMotionPolicy</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.get_motion_policy">
<span class="sig-name descname"><span class="pre">get_motion_policy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#omni.isaac.motion_generation.MotionPolicy" title="omni.isaac.motion_generation.motion_policy_interface.MotionPolicy"><span class="pre">omni.isaac.motion_generation.motion_policy_interface.MotionPolicy</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.get_motion_policy" title="Permalink to this definition"></a></dt>
<dd><p>Get MotionPolicy object that is being used to generate robot motions</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An instance of a MotionPolicy that is being used to compute robot motions</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#omni.isaac.motion_generation.MotionPolicy" title="omni.isaac.motion_generation.MotionPolicy">MotionPolicy</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.remove_obstacle">
<span class="sig-name descname"><span class="pre">remove_obstacle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obstacle:</span> <span class="pre">&lt;module</span> <span class="pre">'omni.isaac.core.objects'</span> <span class="pre">from</span> <span class="pre">'/buildAgent/work/471f8e01c9575c12/_build/linux-x86_64/release/exts/omni.isaac.core/omni/isaac/core/objects/__init__.py'&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.remove_obstacle" title="Permalink to this definition"></a></dt>
<dd><p>Remove and added obstacle from the motion_policy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obstacle</strong> (<em>omni.isaac.core.objects</em>) – Object from omni.isaac.core.objects that has been added to the motion_policy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.motion_policy_controller.MotionPolicyController.reset" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-omni.isaac.motion_generation.wheel_base_pose_controller">
<span id="wheel-base-pose-controller"></span><h2>Wheel Base Pose Controller<a class="headerlink" href="#module-omni.isaac.motion_generation.wheel_base_pose_controller" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.wheel_base_pose_controller.WheelBasePoseController">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">WheelBasePoseController</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">open_loop_wheel_controller</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.controllers.BaseController" title="omni.isaac.core.controllers.base_controller.BaseController"><span class="pre">omni.isaac.core.controllers.base_controller.BaseController</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_holonomic</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#omni.isaac.motion_generation.wheel_base_pose_controller.WheelBasePoseController" title="Permalink to this definition"></a></dt>
<dd><p>[summary]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – [description]</p></li>
<li><p><strong>open_loop_wheel_controller</strong> (<a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.controllers.BaseController" title="omni.isaac.core.controllers.BaseController"><em>BaseController</em></a>) – A controller that takes in a command of
[longitudinal velocity, steering angle] and returns the
ArticulationAction to be applied to the wheels if non holonomic.
and [longitudinal velocity, latitude velocity, steering angle]
if holonomic.</p></li>
<li><p><strong>is_holonomic</strong> (<em>bool</em><em>, </em><em>optional</em>) – [description]. Defaults to False.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.wheel_base_pose_controller.WheelBasePoseController.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">goal_position</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lateral_velocity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yaw_velocity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heading_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">position_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.04</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction"><span class="pre">omni.isaac.core.utils.types.ArticulationAction</span></a></span></span><a class="headerlink" href="#omni.isaac.motion_generation.wheel_base_pose_controller.WheelBasePoseController.forward" title="Permalink to this definition"></a></dt>
<dd><p>[summary]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_position</strong> (<em>np.ndarray</em>) – [description]</p></li>
<li><p><strong>start_orientation</strong> (<em>np.ndarray</em>) – [description]</p></li>
<li><p><strong>goal_position</strong> (<em>np.ndarray</em>) – [description]</p></li>
<li><p><strong>lateral_velocity</strong> (<em>float</em><em>, </em><em>optional</em>) – [description]. Defaults to 20.0.</p></li>
<li><p><strong>yaw_velocity</strong> (<em>float</em><em>, </em><em>optional</em>) – [description]. Defaults to 0.5.</p></li>
<li><p><strong>heading_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – [description]. Defaults to 0.05.</p></li>
<li><p><strong>position_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – [description]. Defaults to 4.0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[description]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../../omni.isaac.core/docs/index.html#omni.isaac.core.utils.types.ArticulationAction" title="omni.isaac.core.utils.types.ArticulationAction">ArticulationAction</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="omni.isaac.motion_generation.wheel_base_pose_controller.WheelBasePoseController.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#omni.isaac.motion_generation.wheel_base_pose_controller.WheelBasePoseController.reset" title="Permalink to this definition"></a></dt>
<dd><p>[summary]</p>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-2023, NVIDIA.
      <span class="lastupdated">Last updated on Mar 16, 2023.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>